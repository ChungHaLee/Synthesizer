/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/fft.js/lib/fft.js":
/*!****************************************!*\
  !*** ./node_modules/fft.js/lib/fft.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nfunction FFT(size) {\r\n  this.size = size | 0;\r\n  if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\r\n    throw new Error('FFT size must be a power of two and bigger than 1');\r\n\r\n  this._csize = size << 1;\r\n\r\n  // NOTE: Use of `var` is intentional for old V8 versions\r\n  var table = new Array(this.size * 2);\r\n  for (var i = 0; i < table.length; i += 2) {\r\n    const angle = Math.PI * i / this.size;\r\n    table[i] = Math.cos(angle);\r\n    table[i + 1] = -Math.sin(angle);\r\n  }\r\n  this.table = table;\r\n\r\n  // Find size's power of two\r\n  var power = 0;\r\n  for (var t = 1; this.size > t; t <<= 1)\r\n    power++;\r\n\r\n  // Calculate initial step's width:\r\n  //   * If we are full radix-4 - it is 2x smaller to give inital len=8\r\n  //   * Otherwise it is the same as `power` to give len=4\r\n  this._width = power % 2 === 0 ? power - 1 : power;\r\n\r\n  // Pre-compute bit-reversal patterns\r\n  this._bitrev = new Array(1 << this._width);\r\n  for (var j = 0; j < this._bitrev.length; j++) {\r\n    this._bitrev[j] = 0;\r\n    for (var shift = 0; shift < this._width; shift += 2) {\r\n      var revShift = this._width - shift - 2;\r\n      this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\r\n    }\r\n  }\r\n\r\n  this._out = null;\r\n  this._data = null;\r\n  this._inv = 0;\r\n}\r\nmodule.exports = FFT;\r\n\r\nFFT.prototype.fromComplexArray = function fromComplexArray(complex, storage) {\r\n  var res = storage || new Array(complex.length >>> 1);\r\n  for (var i = 0; i < complex.length; i += 2)\r\n    res[i >>> 1] = complex[i];\r\n  return res;\r\n};\r\n\r\nFFT.prototype.createComplexArray = function createComplexArray() {\r\n  const res = new Array(this._csize);\r\n  for (var i = 0; i < res.length; i++)\r\n    res[i] = 0;\r\n  return res;\r\n};\r\n\r\nFFT.prototype.toComplexArray = function toComplexArray(input, storage) {\r\n  var res = storage || this.createComplexArray();\r\n  for (var i = 0; i < res.length; i += 2) {\r\n    res[i] = input[i >>> 1];\r\n    res[i + 1] = 0;\r\n  }\r\n  return res;\r\n};\r\n\r\nFFT.prototype.completeSpectrum = function completeSpectrum(spectrum) {\r\n  var size = this._csize;\r\n  var half = size >>> 1;\r\n  for (var i = 2; i < half; i += 2) {\r\n    spectrum[size - i] = spectrum[i];\r\n    spectrum[size - i + 1] = -spectrum[i + 1];\r\n  }\r\n};\r\n\r\nFFT.prototype.transform = function transform(out, data) {\r\n  if (out === data)\r\n    throw new Error('Input and output buffers must be different');\r\n\r\n  this._out = out;\r\n  this._data = data;\r\n  this._inv = 0;\r\n  this._transform4();\r\n  this._out = null;\r\n  this._data = null;\r\n};\r\n\r\nFFT.prototype.realTransform = function realTransform(out, data) {\r\n  if (out === data)\r\n    throw new Error('Input and output buffers must be different');\r\n\r\n  this._out = out;\r\n  this._data = data;\r\n  this._inv = 0;\r\n  this._realTransform4();\r\n  this._out = null;\r\n  this._data = null;\r\n};\r\n\r\nFFT.prototype.inverseTransform = function inverseTransform(out, data) {\r\n  if (out === data)\r\n    throw new Error('Input and output buffers must be different');\r\n\r\n  this._out = out;\r\n  this._data = data;\r\n  this._inv = 1;\r\n  this._transform4();\r\n  for (var i = 0; i < out.length; i++)\r\n    out[i] /= this.size;\r\n  this._out = null;\r\n  this._data = null;\r\n};\r\n\r\n// radix-4 implementation\r\n//\r\n// NOTE: Uses of `var` are intentional for older V8 version that do not\r\n// support both `let compound assignments` and `const phi`\r\nFFT.prototype._transform4 = function _transform4() {\r\n  var out = this._out;\r\n  var size = this._csize;\r\n\r\n  // Initial step (permute and transform)\r\n  var width = this._width;\r\n  var step = 1 << width;\r\n  var len = (size / step) << 1;\r\n\r\n  var outOff;\r\n  var t;\r\n  var bitrev = this._bitrev;\r\n  if (len === 4) {\r\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\r\n      const off = bitrev[t];\r\n      this._singleTransform2(outOff, off, step);\r\n    }\r\n  } else {\r\n    // len === 8\r\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\r\n      const off = bitrev[t];\r\n      this._singleTransform4(outOff, off, step);\r\n    }\r\n  }\r\n\r\n  // Loop through steps in decreasing order\r\n  var inv = this._inv ? -1 : 1;\r\n  var table = this.table;\r\n  for (step >>= 2; step >= 2; step >>= 2) {\r\n    len = (size / step) << 1;\r\n    var quarterLen = len >>> 2;\r\n\r\n    // Loop through offsets in the data\r\n    for (outOff = 0; outOff < size; outOff += len) {\r\n      // Full case\r\n      var limit = outOff + quarterLen;\r\n      for (var i = outOff, k = 0; i < limit; i += 2, k += step) {\r\n        const A = i;\r\n        const B = A + quarterLen;\r\n        const C = B + quarterLen;\r\n        const D = C + quarterLen;\r\n\r\n        // Original values\r\n        const Ar = out[A];\r\n        const Ai = out[A + 1];\r\n        const Br = out[B];\r\n        const Bi = out[B + 1];\r\n        const Cr = out[C];\r\n        const Ci = out[C + 1];\r\n        const Dr = out[D];\r\n        const Di = out[D + 1];\r\n\r\n        // Middle values\r\n        const MAr = Ar;\r\n        const MAi = Ai;\r\n\r\n        const tableBr = table[k];\r\n        const tableBi = inv * table[k + 1];\r\n        const MBr = Br * tableBr - Bi * tableBi;\r\n        const MBi = Br * tableBi + Bi * tableBr;\r\n\r\n        const tableCr = table[2 * k];\r\n        const tableCi = inv * table[2 * k + 1];\r\n        const MCr = Cr * tableCr - Ci * tableCi;\r\n        const MCi = Cr * tableCi + Ci * tableCr;\r\n\r\n        const tableDr = table[3 * k];\r\n        const tableDi = inv * table[3 * k + 1];\r\n        const MDr = Dr * tableDr - Di * tableDi;\r\n        const MDi = Dr * tableDi + Di * tableDr;\r\n\r\n        // Pre-Final values\r\n        const T0r = MAr + MCr;\r\n        const T0i = MAi + MCi;\r\n        const T1r = MAr - MCr;\r\n        const T1i = MAi - MCi;\r\n        const T2r = MBr + MDr;\r\n        const T2i = MBi + MDi;\r\n        const T3r = inv * (MBr - MDr);\r\n        const T3i = inv * (MBi - MDi);\r\n\r\n        // Final values\r\n        const FAr = T0r + T2r;\r\n        const FAi = T0i + T2i;\r\n\r\n        const FCr = T0r - T2r;\r\n        const FCi = T0i - T2i;\r\n\r\n        const FBr = T1r + T3i;\r\n        const FBi = T1i - T3r;\r\n\r\n        const FDr = T1r - T3i;\r\n        const FDi = T1i + T3r;\r\n\r\n        out[A] = FAr;\r\n        out[A + 1] = FAi;\r\n        out[B] = FBr;\r\n        out[B + 1] = FBi;\r\n        out[C] = FCr;\r\n        out[C + 1] = FCi;\r\n        out[D] = FDr;\r\n        out[D + 1] = FDi;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// radix-2 implementation\r\n//\r\n// NOTE: Only called for len=4\r\nFFT.prototype._singleTransform2 = function _singleTransform2(outOff, off,\r\n                                                             step) {\r\n  const out = this._out;\r\n  const data = this._data;\r\n\r\n  const evenR = data[off];\r\n  const evenI = data[off + 1];\r\n  const oddR = data[off + step];\r\n  const oddI = data[off + step + 1];\r\n\r\n  const leftR = evenR + oddR;\r\n  const leftI = evenI + oddI;\r\n  const rightR = evenR - oddR;\r\n  const rightI = evenI - oddI;\r\n\r\n  out[outOff] = leftR;\r\n  out[outOff + 1] = leftI;\r\n  out[outOff + 2] = rightR;\r\n  out[outOff + 3] = rightI;\r\n};\r\n\r\n// radix-4\r\n//\r\n// NOTE: Only called for len=8\r\nFFT.prototype._singleTransform4 = function _singleTransform4(outOff, off,\r\n                                                             step) {\r\n  const out = this._out;\r\n  const data = this._data;\r\n  const inv = this._inv ? -1 : 1;\r\n  const step2 = step * 2;\r\n  const step3 = step * 3;\r\n\r\n  // Original values\r\n  const Ar = data[off];\r\n  const Ai = data[off + 1];\r\n  const Br = data[off + step];\r\n  const Bi = data[off + step + 1];\r\n  const Cr = data[off + step2];\r\n  const Ci = data[off + step2 + 1];\r\n  const Dr = data[off + step3];\r\n  const Di = data[off + step3 + 1];\r\n\r\n  // Pre-Final values\r\n  const T0r = Ar + Cr;\r\n  const T0i = Ai + Ci;\r\n  const T1r = Ar - Cr;\r\n  const T1i = Ai - Ci;\r\n  const T2r = Br + Dr;\r\n  const T2i = Bi + Di;\r\n  const T3r = inv * (Br - Dr);\r\n  const T3i = inv * (Bi - Di);\r\n\r\n  // Final values\r\n  const FAr = T0r + T2r;\r\n  const FAi = T0i + T2i;\r\n\r\n  const FBr = T1r + T3i;\r\n  const FBi = T1i - T3r;\r\n\r\n  const FCr = T0r - T2r;\r\n  const FCi = T0i - T2i;\r\n\r\n  const FDr = T1r - T3i;\r\n  const FDi = T1i + T3r;\r\n\r\n  out[outOff] = FAr;\r\n  out[outOff + 1] = FAi;\r\n  out[outOff + 2] = FBr;\r\n  out[outOff + 3] = FBi;\r\n  out[outOff + 4] = FCr;\r\n  out[outOff + 5] = FCi;\r\n  out[outOff + 6] = FDr;\r\n  out[outOff + 7] = FDi;\r\n};\r\n\r\n// Real input radix-4 implementation\r\nFFT.prototype._realTransform4 = function _realTransform4() {\r\n  var out = this._out;\r\n  var size = this._csize;\r\n\r\n  // Initial step (permute and transform)\r\n  var width = this._width;\r\n  var step = 1 << width;\r\n  var len = (size / step) << 1;\r\n\r\n  var outOff;\r\n  var t;\r\n  var bitrev = this._bitrev;\r\n  if (len === 4) {\r\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\r\n      const off = bitrev[t];\r\n      this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\r\n    }\r\n  } else {\r\n    // len === 8\r\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\r\n      const off = bitrev[t];\r\n      this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\r\n    }\r\n  }\r\n\r\n  // Loop through steps in decreasing order\r\n  var inv = this._inv ? -1 : 1;\r\n  var table = this.table;\r\n  for (step >>= 2; step >= 2; step >>= 2) {\r\n    len = (size / step) << 1;\r\n    var halfLen = len >>> 1;\r\n    var quarterLen = halfLen >>> 1;\r\n    var hquarterLen = quarterLen >>> 1;\r\n\r\n    // Loop through offsets in the data\r\n    for (outOff = 0; outOff < size; outOff += len) {\r\n      for (var i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\r\n        var A = outOff + i;\r\n        var B = A + quarterLen;\r\n        var C = B + quarterLen;\r\n        var D = C + quarterLen;\r\n\r\n        // Original values\r\n        var Ar = out[A];\r\n        var Ai = out[A + 1];\r\n        var Br = out[B];\r\n        var Bi = out[B + 1];\r\n        var Cr = out[C];\r\n        var Ci = out[C + 1];\r\n        var Dr = out[D];\r\n        var Di = out[D + 1];\r\n\r\n        // Middle values\r\n        var MAr = Ar;\r\n        var MAi = Ai;\r\n\r\n        var tableBr = table[k];\r\n        var tableBi = inv * table[k + 1];\r\n        var MBr = Br * tableBr - Bi * tableBi;\r\n        var MBi = Br * tableBi + Bi * tableBr;\r\n\r\n        var tableCr = table[2 * k];\r\n        var tableCi = inv * table[2 * k + 1];\r\n        var MCr = Cr * tableCr - Ci * tableCi;\r\n        var MCi = Cr * tableCi + Ci * tableCr;\r\n\r\n        var tableDr = table[3 * k];\r\n        var tableDi = inv * table[3 * k + 1];\r\n        var MDr = Dr * tableDr - Di * tableDi;\r\n        var MDi = Dr * tableDi + Di * tableDr;\r\n\r\n        // Pre-Final values\r\n        var T0r = MAr + MCr;\r\n        var T0i = MAi + MCi;\r\n        var T1r = MAr - MCr;\r\n        var T1i = MAi - MCi;\r\n        var T2r = MBr + MDr;\r\n        var T2i = MBi + MDi;\r\n        var T3r = inv * (MBr - MDr);\r\n        var T3i = inv * (MBi - MDi);\r\n\r\n        // Final values\r\n        var FAr = T0r + T2r;\r\n        var FAi = T0i + T2i;\r\n\r\n        var FBr = T1r + T3i;\r\n        var FBi = T1i - T3r;\r\n\r\n        out[A] = FAr;\r\n        out[A + 1] = FAi;\r\n        out[B] = FBr;\r\n        out[B + 1] = FBi;\r\n\r\n        // Output final middle point\r\n        if (i === 0) {\r\n          var FCr = T0r - T2r;\r\n          var FCi = T0i - T2i;\r\n          out[C] = FCr;\r\n          out[C + 1] = FCi;\r\n          continue;\r\n        }\r\n\r\n        // Do not overwrite ourselves\r\n        if (i === hquarterLen)\r\n          continue;\r\n\r\n        // In the flipped case:\r\n        // MAi = -MAi\r\n        // MBr=-MBi, MBi=-MBr\r\n        // MCr=-MCr\r\n        // MDr=MDi, MDi=MDr\r\n        var ST0r = T1r;\r\n        var ST0i = -T1i;\r\n        var ST1r = T0r;\r\n        var ST1i = -T0i;\r\n        var ST2r = -inv * T3i;\r\n        var ST2i = -inv * T3r;\r\n        var ST3r = -inv * T2i;\r\n        var ST3i = -inv * T2r;\r\n\r\n        var SFAr = ST0r + ST2r;\r\n        var SFAi = ST0i + ST2i;\r\n\r\n        var SFBr = ST1r + ST3i;\r\n        var SFBi = ST1i - ST3r;\r\n\r\n        var SA = outOff + quarterLen - i;\r\n        var SB = outOff + halfLen - i;\r\n\r\n        out[SA] = SFAr;\r\n        out[SA + 1] = SFAi;\r\n        out[SB] = SFBr;\r\n        out[SB + 1] = SFBi;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// radix-2 implementation\r\n//\r\n// NOTE: Only called for len=4\r\nFFT.prototype._singleRealTransform2 = function _singleRealTransform2(outOff,\r\n                                                                     off,\r\n                                                                     step) {\r\n  const out = this._out;\r\n  const data = this._data;\r\n\r\n  const evenR = data[off];\r\n  const oddR = data[off + step];\r\n\r\n  const leftR = evenR + oddR;\r\n  const rightR = evenR - oddR;\r\n\r\n  out[outOff] = leftR;\r\n  out[outOff + 1] = 0;\r\n  out[outOff + 2] = rightR;\r\n  out[outOff + 3] = 0;\r\n};\r\n\r\n// radix-4\r\n//\r\n// NOTE: Only called for len=8\r\nFFT.prototype._singleRealTransform4 = function _singleRealTransform4(outOff,\r\n                                                                     off,\r\n                                                                     step) {\r\n  const out = this._out;\r\n  const data = this._data;\r\n  const inv = this._inv ? -1 : 1;\r\n  const step2 = step * 2;\r\n  const step3 = step * 3;\r\n\r\n  // Original values\r\n  const Ar = data[off];\r\n  const Br = data[off + step];\r\n  const Cr = data[off + step2];\r\n  const Dr = data[off + step3];\r\n\r\n  // Pre-Final values\r\n  const T0r = Ar + Cr;\r\n  const T1r = Ar - Cr;\r\n  const T2r = Br + Dr;\r\n  const T3r = inv * (Br - Dr);\r\n\r\n  // Final values\r\n  const FAr = T0r + T2r;\r\n\r\n  const FBr = T1r;\r\n  const FBi = -T3r;\r\n\r\n  const FCr = T0r - T2r;\r\n\r\n  const FDr = T1r;\r\n  const FDi = T3r;\r\n\r\n  out[outOff] = FAr;\r\n  out[outOff + 1] = 0;\r\n  out[outOff + 2] = FBr;\r\n  out[outOff + 3] = FBi;\r\n  out[outOff + 4] = FCr;\r\n  out[outOff + 5] = 0;\r\n  out[outOff + 6] = FDr;\r\n  out[outOff + 7] = FDi;\r\n};\r\n\n\n//# sourceURL=webpack://Synthesizer/./node_modules/fft.js/lib/fft.js?");

/***/ }),

/***/ "./node_modules/note-frequency-map/Comparison.js":
/*!*******************************************************!*\
  !*** ./node_modules/note-frequency-map/Comparison.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const frequency = __webpack_require__(/*! ./util/frequency */ \"./node_modules/note-frequency-map/util/frequency.js\");\r\nconst scale = __webpack_require__(/*! ./util/scale */ \"./node_modules/note-frequency-map/util/scale.json\");\r\n\r\nclass Comparison {\r\n\r\n    constructor (note1, note2) {\r\n        this.note1 = note1;\r\n        this.note2 = note2;\r\n\r\n        this.semitones = getSemitones(getAllSemitones(note1, note2));\r\n        this.octaves = getOctaves(getAllSemitones(note1, note2));\r\n\r\n        let semitoneSum = `${this.semitones} semitone${(this.semitones === 1) ? '' : 's'}`;\r\n        let octaveSum = `${this.octaves} octave${(this.octaves === 1) ? '' : 's'}`;\r\n\r\n        if (getAllSemitones(note1, note2) === 0)\r\n        this.summary = `There is no difference between the notes, they are both ${note1.name + note1.octave}`;\r\n        else this.summary = `The note ${this.note1.name + this.note1.octave} is ${(this.octaves === 0) ? '' : octaveSum}${(this.semitones === 0 || this.octaves === 0) ? '' : ' and '}${(this.semitones === 0) ? '' : semitoneSum} away from ${note2.name + note2.octave}`;\r\n    }\r\n}\r\n\r\nfunction getAllSemitones (note1, note2) {\r\n    return frequency.getSemitonesFromNote(note1.name, note1.octave, note2.name, note2.octave);\r\n}\r\n\r\nfunction getSemitones (allSemitones) {\r\n    let result = allSemitones % scale.length;\r\n    if (result === 0) result = 0; // Else, it results in -0, which is ridiculous\r\n    return result;\r\n}\r\n\r\nfunction getOctaves (allSemitones) {\r\n    let result;\r\n    if (allSemitones < 0) {\r\n        result = Math.floor((allSemitones * -1) / scale.length) * -1;\r\n        if (result === 0) result = 0; // Else, it results in -0, which is ridiculous\r\n    }\r\n    else result = Math.floor(allSemitones / scale.length);\r\n    return result;\r\n}\r\n\r\nmodule.exports = Comparison;\n\n//# sourceURL=webpack://Synthesizer/./node_modules/note-frequency-map/Comparison.js?");

/***/ }),

/***/ "./node_modules/note-frequency-map/Error.js":
/*!**************************************************!*\
  !*** ./node_modules/note-frequency-map/Error.js ***!
  \**************************************************/
/***/ ((module) => {

eval("let codes = [\r\n    {\r\n        code: 'ERR_SYNTAX_NOTE',\r\n        err:'That note does not exist'\r\n    },\r\n    {\r\n        code: 'ERR_SYNTAX_TOO_MANY_CHARS',\r\n        err: 'Too many characters'\r\n    },\r\n    {\r\n        code: 'ERR_SYNTAX_PITCHED',\r\n        err: 'Invalid pitch modifier'\r\n    },\r\n    {\r\n        code: 'ERR_SYNTAX_OCTAVE',\r\n        err: 'The octave was not set properly'\r\n    },\r\n    {\r\n        code: 'ERR_SYNTAX_TOO_FEW_CHARS',\r\n        err: 'Too few characters'\r\n    },\r\n    {\r\n        code: 'ERR_NOTE_TOO_HIGH',\r\n        err: 'The note is too high'\r\n    },\r\n    {\r\n        code: 'ERR_NOTE_TOO_LOW',\r\n        err: 'The note is too low'\r\n    },\r\n    {\r\n        code: 'ERR_FREQUENCY_OUT_OF_RANGE',\r\n        err: 'The frequency is either too low or too high'\r\n    }\r\n]\r\n\r\nclass Error {\r\n    constructor (id, extra, input) {\r\n        this.id = id;\r\n        this.extra = extra;\r\n        this.input = input;\r\n        this.code = codes[id].code;\r\n        this.err = codes[id].err;\r\n    }\r\n}\r\n\r\nmodule.exports = Error;\n\n//# sourceURL=webpack://Synthesizer/./node_modules/note-frequency-map/Error.js?");

/***/ }),

/***/ "./node_modules/note-frequency-map/Note.js":
/*!*************************************************!*\
  !*** ./node_modules/note-frequency-map/Note.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const frequency = __webpack_require__(/*! ./util/frequency */ \"./node_modules/note-frequency-map/util/frequency.js\");\r\nconst Comparison = __webpack_require__(/*! ./Comparison */ \"./node_modules/note-frequency-map/Comparison.js\");\r\nconst Error = __webpack_require__(/*! ./Error */ \"./node_modules/note-frequency-map/Error.js\");\r\n\r\nclass Note {\r\n    constructor (name, octave, freq, rootNote) {\r\n        this.name = name;\r\n        this.octave = octave;\r\n        this.note;\r\n        this.tuning = {\r\n            name: rootNote.name,\r\n            octave: rootNote.octave,\r\n            frequency: rootNote.frequency\r\n        };\r\n\r\n        if (freq === null) {\r\n            this.frequency = frequency.fromNote(this, this.tuning);\r\n            this.centsOff = 0;\r\n        } else {\r\n            this.frequency = freq;\r\n            let checkedName = name || null;\r\n            let checkedOctave = octave || null;\r\n            let closest = frequency.getCentsOffFromNote(checkedName, checkedOctave, freq, rootNote);\r\n            if (closest !== false) {\r\n                this.centsOff = closest.cents;\r\n                this.name = closest.note.name;\r\n                this.octave = closest.note.octave;\r\n            } else this.err = new Error(7, `The frequency \"${freq}\" is out of range`, freq);\r\n        }\r\n\r\n        if (this.name !== null && this.octave !== null) {\r\n            this.note = this.name + this.octave;\r\n        }\r\n    }\r\n\r\n    transpose (semitones) {\r\n        frequency.transpose(this, semitones);\r\n    }\r\n\r\n    compare (note) {\r\n        return new Comparison(this, note);\r\n    }\r\n}\r\n\r\nmodule.exports = Note;\n\n//# sourceURL=webpack://Synthesizer/./node_modules/note-frequency-map/Note.js?");

/***/ }),

/***/ "./node_modules/note-frequency-map/app.js":
/*!************************************************!*\
  !*** ./node_modules/note-frequency-map/app.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parser = __webpack_require__(/*! ./util/parser */ \"./node_modules/note-frequency-map/util/parser.js\");\r\nconst Note = __webpack_require__(/*! ./Note */ \"./node_modules/note-frequency-map/Note.js\");\r\n\r\nlet rootNote = {\r\n    name: 'A',\r\n    octave: 4,\r\n    frequency: 440\r\n}\r\n\r\nfunction setRoot (note, freq) {\r\n    let parsed = parser.parseString(note);\r\n    if (parsed.err !== undefined) return false;\r\n    if (isNaN(freq) || freq <= 0) return false;\r\n    rootNote.name = parsed.name;\r\n    rootNote.octave = parsed.octave;\r\n    rootNote.frequency = freq;\r\n    return true;\r\n}\r\n\r\nfunction noteFromName (note) {\r\n    let parsed = parser.parseString(note);\r\n    return new Note(parsed.name, parsed.octave, null, rootNote);\r\n}\r\n\r\nfunction noteFromFreq (freq) {\r\n    return new Note(null, null, freq, rootNote);\r\n}\r\n\r\nmodule.exports = {\r\n    setRoot: (string, freq) => setRoot(string, freq),\r\n    noteFromName: string => noteFromName(string),\r\n    noteFromFreq: float => noteFromFreq(float)\r\n}\r\n\n\n//# sourceURL=webpack://Synthesizer/./node_modules/note-frequency-map/app.js?");

/***/ }),

/***/ "./node_modules/note-frequency-map/util/frequency.js":
/*!***********************************************************!*\
  !*** ./node_modules/note-frequency-map/util/frequency.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const scale = __webpack_require__(/*! ./scale */ \"./node_modules/note-frequency-map/util/scale.json\");\r\n\r\nfunction fromNote (note) { // Note object\r\n    return calculate(note.name, note.octave, note.tuning);\r\n}\r\n\r\n// This function finds how much off the note is from either a defined one, or the closest one\r\nfunction getCentsOffFromNote (name, octave, freq, rootNote) {\r\n    let closestNoteName = name;\r\n    let closestNoteOctave = octave\r\n    // If no note is choosen, find the closest note\r\n    if (closestNoteName === null || closestNoteOctave === null) {\r\n\r\n        // First find the octave\r\n        for (let i = -3; i < 40; i++) {\r\n            let minFreq = calculate(scale[0], i, rootNote) / getHalfStepSize();\r\n            let maxFreq = calculate(scale[scale.length - 1], i, rootNote) * getHalfStepSize();\r\n\r\n            // Octave is not found, continue to next octave\r\n            if (!(freq >= minFreq && freq <= maxFreq)) continue;\r\n\r\n            // Octave was found, try to find the note.\r\n            closestNoteOctave = i;\r\n\r\n            // Find the closest note\r\n            for (let i = 0; i < scale.length; i++) {\r\n                let currentNoteFreq = calculate(scale[i], closestNoteOctave, rootNote);\r\n                let centsDiff = centsDifference(currentNoteFreq, freq);\r\n                if (centsDiff <= 50 && centsDiff > -50) {\r\n                    closestNoteName = scale[i];\r\n                    break;\r\n                }\r\n            }\r\n            if (closestNoteName === null) continue;\r\n        }\r\n        \r\n        // If the octave wasn't found\r\n        if (closestNoteOctave === null) return false;\r\n        // If the note wasn't found\r\n        if (closestNoteName === null) return false;\r\n\r\n    }\r\n    return {\r\n        note: {\r\n            name: closestNoteName,\r\n            octave: closestNoteOctave\r\n        },\r\n        cents: centsDifference(calculate(closestNoteName, closestNoteOctave, rootNote), freq)\r\n    }\r\n}\r\n\r\nfunction centsDifference (f1, f2) {\r\n\treturn 1200*(Math.log(f2/f1)/Math.log(2))\r\n}\r\n\r\nfunction transpose (note, octave, semitones) {\r\n    let index = scale.indexOf(note.name) + semitones;\r\n    let newOctave = note.octave;\r\n\r\n    while (index < 0) {\r\n        index += scale.length;\r\n        newOctave--;\r\n    }\r\n\r\n    while (index > scale.length - 1) {\r\n        index -= scale.length;\r\n        newOctave++;\r\n    }\r\n\r\n    if (newOctave < 0) {\r\n        return new Error(7, `This result in octave being \"${octave}\"`, string);\r\n    }\r\n\r\n    note.octave = newOctave;\r\n    note.name = scale[index];\r\n}\r\n\r\nfunction getSemitonesFromNote (name1, octave1, name2, octave2) {\r\n    let semitones = scale.indexOf(name1) - scale.indexOf(name2);\r\n    let octaves = octave1 - octave2;\r\n    return semitones + (octaves * scale.length);\r\n}\r\n\r\nfunction getSemitonesFromRoot (name, octave, rootNote) {\r\n    return getSemitonesFromNote(name, octave, rootNote.name, rootNote.octave);\r\n}\r\n\r\nfunction getFullStepSize () {\r\n    return getStepSize(scale.length);\r\n}\r\n\r\nfunction getHalfStepSize () {\r\n    return getStepSize(scale.length * 2);\r\n}\r\n\r\nfunction getStepSize (count) {\r\n    return Math.pow(2, 1/count);\r\n}\r\n\r\nfunction calculate (name, octave, rootNote) {\r\n    return rootNote.frequency * Math.pow(getFullStepSize(), getSemitonesFromRoot(name, octave, rootNote));\r\n}\r\n\r\nmodule.exports.fromNote = fromNote;\r\nmodule.exports.transpose = transpose;\r\nmodule.exports.getSemitonesFromNote = getSemitonesFromNote;\r\nmodule.exports.getCentsOffFromNote = getCentsOffFromNote;\n\n//# sourceURL=webpack://Synthesizer/./node_modules/note-frequency-map/util/frequency.js?");

/***/ }),

/***/ "./node_modules/note-frequency-map/util/parser.js":
/*!********************************************************!*\
  !*** ./node_modules/note-frequency-map/util/parser.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const scale = __webpack_require__(/*! ./scale */ \"./node_modules/note-frequency-map/util/scale.json\");\r\nconst symbols = __webpack_require__(/*! ./symbols */ \"./node_modules/note-frequency-map/util/symbols.json\");\r\nconst Error = __webpack_require__(/*! ../Error */ \"./node_modules/note-frequency-map/Error.js\");\r\n\r\nfunction parseString (string) {\r\n    let input = string.split('');\r\n    let inputNoPitching = null;\r\n    let name = null;\r\n    let pitched = null;\r\n    let octave = null;\r\n\r\n    // Too few characters\r\n    if (input.length < 2) {\r\n        return new Error(4, ``, string);\r\n    }\r\n\r\n    // Too many characters\r\n    if (input.length > 3) {\r\n        return new Error(1, `The characters \"${string.substring(3).split('').join(',')}\" is exceeding the max number of characters allowed`, string);\r\n    }\r\n\r\n    // If string includes flat or sharp\r\n    if (input.length === 3) {\r\n        // If sharp or flat symbol is invalid\r\n        if (!(symbols.sharp.includes(input[1]) || symbols.flat.includes(input[1]))) {\r\n            return new Error(2, `The character \"${input[2]}\" is invalid`, string)\r\n        }\r\n        // Pitch modifier is valid\r\n        pitched = input[1];\r\n        inputNoPitching = Array.from(input[0] + input[2]);\r\n    }\r\n    else {\r\n        inputNoPitching = input;\r\n        pitched = null;\r\n    }\r\n\r\n    // If note name is not valid\r\n    if (!scale.join('').toLowerCase().split('').includes(input[0].toLowerCase())) {\r\n        return new Error(0, `The characer \"${input[0]}\" is invalid`, string);\r\n    }\r\n    \r\n    // If note name is valid\r\n    name = input[0].toUpperCase();\r\n    \r\n    // If octave is not a number\r\n    if (isNaN(inputNoPitching[1])) {\r\n        return new Error(3, `The character \"${inputNoPitching[1]}\" is not a number`, string);\r\n    }\r\n\r\n    // If the octave is valid\r\n    octave = Number(inputNoPitching[1]);\r\n\r\n    // If it's pitched, change the name of the note\r\n    if (pitched !== null) {\r\n        let index = null;\r\n        if (symbols.sharp.includes(pitched)) index = scale.indexOf(name) + 1;\r\n        else index = scale.indexOf(name) - 1;\r\n\r\n        if (index < 0) {\r\n            index = scale.length - 1;\r\n            octave--;\r\n        }\r\n\r\n        if (index > scale.length - 1) {\r\n            index = 0;\r\n            octave++;\r\n        }\r\n\r\n        if (octave < 0) {\r\n            return new Error(7, `This result in octave being \"${octave}\"`, string);\r\n        }\r\n\r\n        name = scale[index];\r\n    }\r\n\r\n    return {name, octave};\r\n}\r\n\r\nmodule.exports.parseString = parseString;\n\n//# sourceURL=webpack://Synthesizer/./node_modules/note-frequency-map/util/parser.js?");

/***/ }),

/***/ "./src/js/audio.js":
/*!*************************!*\
  !*** ./src/js/audio.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FileChange\": () => (/* binding */ FileChange),\n/* harmony export */   \"analyser\": () => (/* binding */ analyser),\n/* harmony export */   \"audio\": () => (/* binding */ audio),\n/* harmony export */   \"audio_context\": () => (/* binding */ audio_context),\n/* harmony export */   \"bufferLength\": () => (/* binding */ bufferLength),\n/* harmony export */   \"colorByPitch\": () => (/* binding */ colorByPitch),\n/* harmony export */   \"colorByPitchMulti\": () => (/* binding */ colorByPitchMulti),\n/* harmony export */   \"dataArray\": () => (/* binding */ dataArray),\n/* harmony export */   \"myNote\": () => (/* binding */ myNote),\n/* harmony export */   \"octave\": () => (/* binding */ octave),\n/* harmony export */   \"pitchDetector\": () => (/* binding */ pitchDetector),\n/* harmony export */   \"randomEnergy\": () => (/* binding */ randomEnergy),\n/* harmony export */   \"src\": () => (/* binding */ src),\n/* harmony export */   \"updatePitch\": () => (/* binding */ updatePitch)\n/* harmony export */ });\n/* harmony import */ var pitchy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pitchy */ \"./node_modules/pitchy/index.js\");\n/* harmony import */ var note_frequency_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! note-frequency-map */ \"./node_modules/note-frequency-map/app.js\");\n/* harmony import */ var note_frequency_map__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(note_frequency_map__WEBPACK_IMPORTED_MODULE_1__);\n\r\n\r\n\r\nlet file, audio;\r\nvar audio_context;\r\nvar myNote, octave;\r\n\r\nlet analyser, src, bufferLength, dataArray;\r\nlet chroma, maxChroma, energy, amplitudeSpectrum, pitchColor, pitch, multipitchColor, multipitch;\r\n\r\n\r\nlet filepath = document.getElementById(\"filepath\")\r\n\r\n\r\n// volume control\r\n\r\n$(\"#volume\").slider({\r\n    min: 0,\r\n    max: 100,\r\n    value: 0,\r\n      range: \"min\",\r\n    slide: function(event, ui) {\r\n      setVolume(ui.value / 100);\r\n    }\r\n  });\r\n  \r\n  var myMedia = document.createElement('audio');\r\n  $('#player').append(myMedia);\r\n  myMedia.id = \"myMedia\";\r\n\r\n//   playAudio(audio, 0);\r\n  \r\n//   function playAudio(fileName, myVolume) {\r\n//           myMedia.src = fileName;\r\n//           myMedia.setAttribute('loop', 'loop');\r\n//       setVolume(myVolume);\r\n//       myMedia.play();\r\n//   }\r\n  \r\n  function setVolume(myVolume) {\r\n  var myMedia = document.getElementById('audio');\r\n  myMedia.volume = myVolume;\r\n  }\r\n\r\n\r\n// LOAD MUSIC (vizInit)\r\n\r\nfunction FileInit() {\r\n\r\n    file = document.getElementById(\"thefile\");\r\n    audio = document.getElementById(\"audio\");\r\n    audio_context = audio_context || new AudioContext();\r\n    //filepath.innerHTML = audio.src\r\n\r\n  }\r\n\r\n\r\n\r\nfunction FileChange(){\r\n\r\n    file.onchange = function(){\r\n\r\n        audio_context.resume();\r\n        audio.load(); //load the new source\r\n\r\n        let files = this.files;\r\n\r\n        audio.src = URL.createObjectURL(files[0]);\r\n\r\n        \r\n        if (!src) {\r\n            src = audio_context.createMediaElementSource(audio);\r\n            analyser = audio_context.createAnalyser();\r\n            src.connect(analyser);\r\n            analyser.connect(audio_context.destination);\r\n        }\r\n        console.log(src)\r\n\r\n        AnalyzerPlay(audio_context, src);\r\n        //filepath.innerHTML = audio.src\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nfunction updatePitch(analyser, detector, input, sampleRate) {\r\n    analyser.getFloatTimeDomainData(input);\r\n    let [pitch, clarity] = detector.findPitch(input, sampleRate);\r\n    myNote = note_frequency_map__WEBPACK_IMPORTED_MODULE_1___default().noteFromFreq(pitch);\r\n    octave = myNote.octave\r\n}\r\n\r\n\r\n\r\n\r\n\r\nfunction pitchDetector(){\r\n    const detector = pitchy__WEBPACK_IMPORTED_MODULE_0__.PitchDetector.forFloat32Array(analyser.fftSize);\r\n    const input = new Float32Array(detector.inputLength);\r\n    updatePitch(analyser, detector, input, audio_context.sampleRate);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction AnalyzerPlay(audio_context, src) {\r\n    analyser = audio_context.createAnalyser();\r\n    src.connect(analyser);\r\n    analyser.connect(audio_context.destination);\r\n    analyser.fftSize = 512;\r\n    bufferLength = analyser.frequencyBinCount;\r\n    dataArray = new Uint8Array(bufferLength);\r\n    // energy = 0;\r\n\r\n\r\n    const meyda_analyser = Meyda.createMeydaAnalyzer({\r\n\r\n        audioContext: audio_context,\r\n        source: src,\r\n        buffersize: 1024,\r\n        featureExtractors: [\"energy\"],\r\n        callback: (features) => {\r\n            energy = features['energy']\r\n            energy = energy * 10\r\n\r\n            //console.log('energy:', energy);\r\n        }\r\n    })\r\n    meyda_analyser.start();\r\n}\r\n\r\n\r\n\r\nfunction randomEnergy(){\r\n  energy = Math.random() * 10\r\n  return energy\r\n}\r\n\r\n\r\nfunction colorByPitch(){\r\n  pitch = Math.random() * 10\r\n  if (pitch < 5){\r\n      pitchColor = '#ff0000'\r\n  } else {\r\n    pitchColor = '#0000FF'\r\n  }\r\n  return pitchColor;\r\n}\r\n\r\n\r\n\r\nfunction colorByPitchMulti(){\r\n  multipitch = Math.random() * 10 \r\n  if (multipitch < 5){\r\n      multipitchColor = '#FA2E2E'\r\n  } else {\r\n    multipitchColor = '#FF19DC'\r\n  } \r\n  return multipitchColor;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://Synthesizer/./src/js/audio.js?");

/***/ }),

/***/ "./node_modules/pitchy/index.js":
/*!**************************************!*\
  !*** ./node_modules/pitchy/index.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Autocorrelator\": () => (/* binding */ Autocorrelator),\n/* harmony export */   \"PitchDetector\": () => (/* binding */ PitchDetector)\n/* harmony export */ });\n/* harmony import */ var fft_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fft.js */ \"./node_modules/fft.js/lib/fft.js\");\n\r\n\r\n/**\r\n * @typedef {Float32Array | Float64Array | number[]} Buffer One of the supported\r\n * buffer types. Other numeric array types may not work correctly.\r\n */\r\n\r\n/**\r\n * A class that can perform autocorrelation on input arrays of a given size.\r\n *\r\n * The class holds internal buffers so that no additional allocations are\r\n * necessary while performing the operation.\r\n *\r\n * @template {Buffer} T the buffer type to use. While inputs to the\r\n * autocorrelation process can be any array-like type, the output buffer\r\n * (whether provided explicitly or using a fresh buffer) is always of this type.\r\n */\r\nclass Autocorrelator {\r\n  /** @private @readonly @type {number} */\r\n  _inputLength;\r\n  /** @private @type {FFT} */\r\n  _fft;\r\n  /** @private @type {(size: number) => T} */\r\n  _bufferSupplier;\r\n  /** @private @type {T} */\r\n  _paddedInputBuffer;\r\n  /** @private @type {T} */\r\n  _transformBuffer;\r\n  /** @private @type {T} */\r\n  _inverseBuffer;\r\n\r\n  /**\r\n   * A helper method to create an {@link Autocorrelator} using\r\n   * {@link Float32Array} buffers.\r\n   *\r\n   * @param inputLength {number} the input array length to support\r\n   * @returns {Autocorrelator<Float32Array>}\r\n   */\r\n  static forFloat32Array(inputLength) {\r\n    return new Autocorrelator(\r\n      inputLength,\r\n      (length) => new Float32Array(length)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * A helper method to create an {@link Autocorrelator} using\r\n   * {@link Float64Array} buffers.\r\n   *\r\n   * @param inputLength {number} the input array length to support\r\n   * @returns {Autocorrelator<Float64Array>}\r\n   */\r\n  static forFloat64Array(inputLength) {\r\n    return new Autocorrelator(\r\n      inputLength,\r\n      (length) => new Float64Array(length)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * A helper method to create an {@link Autocorrelator} using `number[]`\r\n   * buffers.\r\n   *\r\n   * @param inputLength {number} the input array length to support\r\n   * @returns {Autocorrelator<number[]>}\r\n   */\r\n  static forNumberArray(inputLength) {\r\n    return new Autocorrelator(inputLength, (length) => Array(length));\r\n  }\r\n\r\n  /**\r\n   * Constructs a new {@link Autocorrelator} able to handle input arrays of the\r\n   * given length.\r\n   *\r\n   * @param inputLength {number} the input array length to support. This\r\n   * `Autocorrelator` will only support operation on arrays of this length.\r\n   * @param bufferSupplier {(length: number) => T} the function to use for\r\n   * creating buffers, accepting the length of the buffer to create and\r\n   * returning a new buffer of that length. The values of the returned buffer\r\n   * need not be initialized in any particular way.\r\n   */\r\n  constructor(inputLength, bufferSupplier) {\r\n    if (inputLength < 1) {\r\n      throw new Error(`Input length must be at least one`);\r\n    }\r\n    this._inputLength = inputLength;\r\n    // We need to double the input length to get correct results, and the FFT\r\n    // algorithm we use requires a length that's a power of 2\r\n    this._fft = new fft_js__WEBPACK_IMPORTED_MODULE_0__(ceilPow2(2 * inputLength));\r\n    this._bufferSupplier = bufferSupplier;\r\n    this._paddedInputBuffer = this._bufferSupplier(this._fft.size);\r\n    this._transformBuffer = this._bufferSupplier(2 * this._fft.size);\r\n    this._inverseBuffer = this._bufferSupplier(2 * this._fft.size);\r\n  }\r\n\r\n  /**\r\n   * Returns the supported input length.\r\n   *\r\n   * @returns {number} the supported input length\r\n   */\r\n  get inputLength() {\r\n    return this._inputLength;\r\n  }\r\n\r\n  /**\r\n   * Autocorrelates the given input data.\r\n   *\r\n   * @param input {ArrayLike<number>} the input data to autocorrelate\r\n   * @param output {T} the output buffer into which to write the autocorrelated\r\n   * data. If not provided, a new buffer will be created.\r\n   * @returns {T} `output`\r\n   */\r\n  autocorrelate(input, output = this._bufferSupplier(input.length)) {\r\n    if (input.length !== this._inputLength) {\r\n      throw new Error(\r\n        `Input must have length ${this._inputLength} but had length ${input.length}`\r\n      );\r\n    }\r\n    // Step 0: pad the input array with zeros\r\n    for (let i = 0; i < input.length; i++) {\r\n      this._paddedInputBuffer[i] = input[i];\r\n    }\r\n    for (let i = input.length; i < this._paddedInputBuffer.length; i++) {\r\n      this._paddedInputBuffer[i] = 0;\r\n    }\r\n\r\n    // Step 1: get the DFT of the input array\r\n    this._fft.realTransform(this._transformBuffer, this._paddedInputBuffer);\r\n    // We need to fill in the right half of the array too\r\n    this._fft.completeSpectrum(this._transformBuffer);\r\n    // Step 2: multiply each entry by its conjugate\r\n    const tb = this._transformBuffer;\r\n    for (let i = 0; i < tb.length; i += 2) {\r\n      tb[i] = tb[i] * tb[i] + tb[i + 1] * tb[i + 1];\r\n      tb[i + 1] = 0;\r\n    }\r\n    // Step 3: perform the inverse transform\r\n    this._fft.inverseTransform(this._inverseBuffer, this._transformBuffer);\r\n\r\n    // This last result (the inverse transform) contains the autocorrelation\r\n    // data, which is completely real\r\n    for (let i = 0; i < input.length; i++) {\r\n      output[i] = this._inverseBuffer[2 * i];\r\n    }\r\n    return output;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an array of all the key maximum positions in the given input array.\r\n *\r\n * In McLeod's paper, a key maximum is the highest maximum between a positively\r\n * sloped zero crossing and a negatively sloped one.\r\n *\r\n * TODO: it may be more efficient not to construct a new output array each time,\r\n * but that would also make the code more complicated (more so than the changes\r\n * that were needed to remove the other allocations).\r\n *\r\n * @param input {ArrayLike<number>}\r\n * @returns {number[]}\r\n */\r\nfunction getKeyMaximumIndices(input) {\r\n  // The indices of the key maxima\r\n  /** @type {number[]} */ const keyIndices = [];\r\n  // Whether the last zero crossing found was positively sloped; equivalently,\r\n  // whether we're looking for a key maximum\r\n  let lookingForMaximum = false;\r\n  // The largest local maximum found so far\r\n  let max = -Infinity;\r\n  // The index of the largest local maximum so far\r\n  let maxIndex = -1;\r\n\r\n  for (let i = 1; i < input.length - 1; i++) {\r\n    if (input[i - 1] <= 0 && input[i] > 0) {\r\n      // Positively sloped zero crossing\r\n      lookingForMaximum = true;\r\n      maxIndex = i;\r\n      max = input[i];\r\n    } else if (input[i - 1] > 0 && input[i] <= 0) {\r\n      // Negatively sloped zero crossing\r\n      lookingForMaximum = false;\r\n      if (maxIndex !== -1) {\r\n        keyIndices.push(maxIndex);\r\n      }\r\n    } else if (lookingForMaximum && input[i] > max) {\r\n      max = input[i];\r\n      maxIndex = i;\r\n    }\r\n  }\r\n\r\n  return keyIndices;\r\n}\r\n\r\n/**\r\n * Refines the chosen key maximum index chosen from the given data by\r\n * interpolating a parabola using the key maximum index and its two neighbors\r\n * and finding the position of that parabola's maximum value.\r\n *\r\n * This is described in section 5 of the MPM paper as a way to refine the\r\n * position of the maximum.\r\n *\r\n * @param index {number} the chosen key maximum index. This must be between `1`\r\n * and `data.length - 2`, inclusive, since it and its two neighbors need to be\r\n * valid indexes of `data`.\r\n * @param data {ArrayLike<number>} the input array from which `index` was chosen\r\n * @returns {[number, number]} a pair consisting of the refined key maximum index and the\r\n * interpolated value of `data` at that index (the latter of which is used as a\r\n * measure of clarity)\r\n */\r\nfunction refineResultIndex(index, data) {\r\n  const [x0, x1, x2] = [index - 1, index, index + 1];\r\n  const [y0, y1, y2] = [data[x0], data[x1], data[x2]];\r\n\r\n  // The parabola going through the three data points can be written as\r\n  // y = y0(x - x1)(x - x2)/(x0 - x1)(x0 - x2)\r\n  //   + y1(x - x0)(x - x2)/(x1 - x0)(x1 - x2)\r\n  //   + y2(x - x0)(x - x1)/(x2 - x0)(x2 - x1)\r\n  // Given the definitions of x0, x1, and x2, we can simplify the denominators:\r\n  // y = y0(x - x1)(x - x2)/2\r\n  //   - y1(x - x0)(x - x2)\r\n  //   + y2(x - x0)(x - x1)/2\r\n  // We can expand this out and get the coefficients in standard form:\r\n  // a = y0/2 - y1 + y2/2\r\n  // b = -(y0/2)(x1 + x2) + y1(x0 + x2) - (y2/2)(x0 + x1)\r\n  // c = y0x1x2/2 - y1x0x2 + y2x0x1/2\r\n  // The index of the maximum is -b / 2a (by solving for x where the derivative\r\n  // is 0).\r\n\r\n  const a = y0 / 2 - y1 + y2 / 2;\r\n  const b = -(y0 / 2) * (x1 + x2) + y1 * (x0 + x2) - (y2 / 2) * (x0 + x1);\r\n  const c = (y0 * x1 * x2) / 2 - y1 * x0 * x2 + (y2 * x0 * x1) / 2;\r\n\r\n  const xMax = -b / (2 * a);\r\n  const yMax = a * xMax * xMax + b * xMax + c;\r\n  return [xMax, yMax];\r\n}\r\n\r\n/**\r\n * A class that can detect the pitch of a note from a time-domain input array.\r\n *\r\n * This class uses the McLeod pitch method (MPM) to detect pitches. MPM is\r\n * described in the paper 'A Smarter Way to Find Pitch' by Philip McLeod and\r\n * Geoff Wyvill\r\n * (http://miracle.otago.ac.nz/tartini/papers/A_Smarter_Way_to_Find_Pitch.pdf).\r\n *\r\n * The class holds internal buffers so that a minimal number of additional\r\n * allocations are necessary while performing the operation.\r\n *\r\n * @template {Buffer} T the buffer type to use internally. Inputs to the\r\n * pitch-detection process can be any numeric array type.\r\n */\r\nclass PitchDetector {\r\n  /** @private @type {Autocorrelator<T>} */\r\n  _autocorrelator;\r\n  /** @private @type {T} */\r\n  _nsdfBuffer;\r\n  // TODO: it might be nice if this were configurable\r\n  /** @private @readonly */\r\n  _clarityThreshold = 0.9;\r\n\r\n  /**\r\n   * A helper method to create an {@link PitchDetector} using {@link Float32Array} buffers.\r\n   *\r\n   * @param inputLength {number} the input array length to support\r\n   * @returns {PitchDetector<Float32Array>}\r\n   */\r\n  static forFloat32Array(inputLength) {\r\n    return new PitchDetector(inputLength, (length) => new Float32Array(length));\r\n  }\r\n\r\n  /**\r\n   * A helper method to create an {@link PitchDetector} using {@link Float64Array} buffers.\r\n   *\r\n   * @param inputLength {number} the input array length to support\r\n   * @returns {PitchDetector<Float64Array>}\r\n   */\r\n  static forFloat64Array(inputLength) {\r\n    return new PitchDetector(inputLength, (length) => new Float64Array(length));\r\n  }\r\n\r\n  /**\r\n   * A helper method to create an {@link PitchDetector} using `number[]` buffers.\r\n   *\r\n   * @param inputLength {number} the input array length to support\r\n   * @returns {PitchDetector<number[]>}\r\n   */\r\n  static forNumberArray(inputLength) {\r\n    return new PitchDetector(inputLength, (length) => Array(length));\r\n  }\r\n\r\n  /**\r\n   * Constructs a new {@link PitchDetector} able to handle input arrays of the\r\n   * given length.\r\n   *\r\n   * @param inputLength {number} the input array length to support. This\r\n   * `PitchDetector` will only support operation on arrays of this length.\r\n   * @param bufferSupplier {(inputLength: number) => T} the function to use for\r\n   * creating buffers, accepting the length of the buffer to create and\r\n   * returning a new buffer of that length. The values of the returned buffer\r\n   * need not be initialized in any particular way.\r\n   */\r\n  constructor(inputLength, bufferSupplier) {\r\n    this._autocorrelator = new Autocorrelator(inputLength, bufferSupplier);\r\n    this._nsdfBuffer = bufferSupplier(inputLength);\r\n  }\r\n\r\n  /**\r\n   * Returns the supported input length.\r\n   *\r\n   * @returns {number} the supported input length\r\n   */\r\n  get inputLength() {\r\n    return this._autocorrelator.inputLength;\r\n  }\r\n\r\n  /**\r\n   * Returns the pitch detected using McLeod Pitch Method (MPM) along with a\r\n   * measure of its clarity.\r\n   *\r\n   * The clarity is a value between 0 and 1 (potentially inclusive) that\r\n   * represents how \"clear\" the pitch was. A clarity value of 1 indicates that\r\n   * the pitch was very distinct, while lower clarity values indicate less\r\n   * definite pitches.\r\n   *\r\n   * @param input {ArrayLike<number>} the time-domain input data\r\n   * @param sampleRate {number} the sample rate at which the input data was\r\n   * collected\r\n   * @returns {[number, number]} the detected pitch, in Hz, followed by the clarity\r\n   */\r\n  findPitch(input, sampleRate) {\r\n    this._nsdf(input);\r\n    const keyMaximumIndices = getKeyMaximumIndices(this._nsdfBuffer);\r\n    if (keyMaximumIndices.length === 0) {\r\n      // No key maxima means that we either don't have enough data to analyze or\r\n      // that the data was flawed (such as an input array of zeroes)\r\n      return [0, 0];\r\n    }\r\n    // The highest key maximum\r\n    const nMax = Math.max(...keyMaximumIndices.map((i) => this._nsdfBuffer[i]));\r\n    // Following the paper, we return the pitch corresponding to the first key\r\n    // maximum higher than K * nMax. This is guaranteed not to be undefined, since\r\n    // we know of at least one key maximum satisfying this condition (whichever\r\n    // key maximum gave us nMax).\r\n    const resultIndex = keyMaximumIndices.find(\r\n      (i) => this._nsdfBuffer[i] >= this._clarityThreshold * nMax\r\n    );\r\n    const [refinedResultIndex, clarity] = refineResultIndex(\r\n      // @ts-expect-error resultIndex is guaranteed to be defined\r\n      resultIndex,\r\n      this._nsdfBuffer\r\n    );\r\n\r\n    // Due to floating point errors, the clarity may occasionally come out to be\r\n    // slightly over 1.0. We can avoid incorrect results by clamping the value.\r\n    return [sampleRate / refinedResultIndex, Math.min(clarity, 1.0)];\r\n  }\r\n\r\n  /**\r\n   * Computes the NSDF of the input and stores it in the internal buffer. This\r\n   * is equation (9) in the McLeod pitch method paper.\r\n   *\r\n   * @private\r\n   * @param input {ArrayLike<number>}\r\n   */\r\n  _nsdf(input) {\r\n    // The function r'(tau) is the autocorrelation\r\n    this._autocorrelator.autocorrelate(input, this._nsdfBuffer);\r\n    // The function m'(tau) (defined in equation (6)) can be computed starting\r\n    // with m'(0), which is equal to 2r'(0), and then iteratively modified to\r\n    // get m'(1), m'(2), etc. For example, to get m'(1), we take m'(0) and\r\n    // subtract x_0^2 and x_{W-1}^2. Then, to get m'(2), we take m'(1) and\r\n    // subtract x_1^2 and x_{W-2}^2, and further values are similar (see the\r\n    // note at the end of section 6 in the MPM paper).\r\n    //\r\n    // The resulting array values are 2 * r'(tau) / m'(tau). We use m below as\r\n    // the incremental value of m'.\r\n    let m = 2 * this._nsdfBuffer[0];\r\n    /** @type {number} */ let i;\r\n    // As pointed out by issuefiler on GitHub, we can take advantage of the fact\r\n    // that m will never increase to avoid division by zero by ending this loop\r\n    // once m === 0. The rest of the array values after m becomes 0 will just be\r\n    // set to 0 themselves. We actually check for m > 0 rather than m === 0\r\n    // because there may be small floating-point errors that cause m to become\r\n    // negative rather than exactly 0.\r\n    for (i = 0; i < this._nsdfBuffer.length && m > 0; i++) {\r\n      this._nsdfBuffer[i] = (2 * this._nsdfBuffer[i]) / m;\r\n      m -= input[i] ** 2 + input[input.length - i - 1] ** 2;\r\n    }\r\n    // If there are any array values remaining, it means m === 0 for those\r\n    // values of tau, so we can just set them to 0\r\n    for (; i < this._nsdfBuffer.length; i++) {\r\n      this._nsdfBuffer[i] = 0;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Rounds up the input to the next power of 2.\r\n *\r\n * @param {number} v\r\n * @returns {number} the next power of 2 at least as large as `v`\r\n */\r\nfunction ceilPow2(v) {\r\n  // https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\r\n  v--;\r\n  v |= v >> 1;\r\n  v |= v >> 2;\r\n  v |= v >> 4;\r\n  v |= v >> 8;\r\n  v |= v >> 16;\r\n  v++;\r\n  return v;\r\n}\r\n\n\n//# sourceURL=webpack://Synthesizer/./node_modules/pitchy/index.js?");

/***/ }),

/***/ "./node_modules/note-frequency-map/util/scale.json":
/*!*********************************************************!*\
  !*** ./node_modules/note-frequency-map/util/scale.json ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('[\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"]');\n\n//# sourceURL=webpack://Synthesizer/./node_modules/note-frequency-map/util/scale.json?");

/***/ }),

/***/ "./node_modules/note-frequency-map/util/symbols.json":
/*!***********************************************************!*\
  !*** ./node_modules/note-frequency-map/util/symbols.json ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"sharp\":[\"#\"],\"flat\":[\"b\",\"♭\"]}');\n\n//# sourceURL=webpack://Synthesizer/./node_modules/note-frequency-map/util/symbols.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/audio.js");
/******/ 	
/******/ })()
;