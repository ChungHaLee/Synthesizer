/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/jsmidgen.js":
/*!****************************!*\
  !*** ./src/js/jsmidgen.js ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar Midi = {};\r\n\r\n(function(exported) {\r\n\r\n\tvar DEFAULT_VOLUME   = exported.DEFAULT_VOLUME   = 90;\r\n\tvar DEFAULT_DURATION = exported.DEFAULT_DURATION = 128;\r\n\tvar DEFAULT_CHANNEL  = exported.DEFAULT_CHANNEL  = 0;\r\n\r\n\t/* ******************************************************************\r\n\t * Utility functions\r\n\t ****************************************************************** */\r\n\r\n\tvar Util = {\r\n\r\n\t\tmidi_letter_pitches: { a:21, b:23, c:12, d:14, e:16, f:17, g:19 },\r\n\r\n\t\t/**\r\n\t\t * Convert a symbolic note name (e.g. \"c4\") to a numeric MIDI pitch (e.g.\r\n\t\t * 60, middle C).\r\n\t\t *\r\n\t\t * @param {string} n - The symbolic note name to parse.\r\n\t\t * @returns {number} The MIDI pitch that corresponds to the symbolic note\r\n\t\t * name.\r\n\t\t */\r\n\t\tmidiPitchFromNote: function(n) {\r\n\t\t\tvar matches = /([a-g])(#+|b+)?([0-9]+)$/i.exec(n);\r\n\t\t\tvar note = matches[1].toLowerCase(), accidental = matches[2] || '', octave = parseInt(matches[3], 10);\r\n\t\t\treturn (12 * octave) + Util.midi_letter_pitches[note] + (accidental.substr(0,1)=='#'?1:-1) * accidental.length;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Ensure that the given argument is converted to a MIDI pitch. Note that\r\n\t\t * it may already be one (including a purely numeric string).\r\n\t\t *\r\n\t\t * @param {string|number} p - The pitch to convert.\r\n\t\t * @returns {number} The resulting numeric MIDI pitch.\r\n\t\t */\r\n\t\tensureMidiPitch: function(p) {\r\n\t\t\tif (typeof p == 'number' || !/[^0-9]/.test(p)) {\r\n\t\t\t\t// numeric pitch\r\n\t\t\t\treturn parseInt(p, 10);\r\n\t\t\t} else {\r\n\t\t\t\t// assume it's a note name\r\n\t\t\t\treturn Util.midiPitchFromNote(p);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tmidi_pitches_letter: { '12':'c', '13':'c#', '14':'d', '15':'d#', '16':'e', '17':'f', '18':'f#', '19':'g', '20':'g#', '21':'a', '22':'a#', '23':'b' },\r\n\t\tmidi_flattened_notes: { 'a#':'bb', 'c#':'db', 'd#':'eb', 'f#':'gb', 'g#':'ab' },\r\n\r\n\t\t/**\r\n\t\t * Convert a numeric MIDI pitch value (e.g. 60) to a symbolic note name\r\n\t\t * (e.g. \"c4\").\r\n\t\t *\r\n\t\t * @param {number} n - The numeric MIDI pitch value to convert.\r\n\t\t * @param {boolean} [returnFlattened=false] - Whether to prefer flattened\r\n\t\t * notes to sharpened ones. Optional, default false.\r\n\t\t * @returns {string} The resulting symbolic note name.\r\n\t\t */\r\n\t\tnoteFromMidiPitch: function(n, returnFlattened) {\r\n\t\t\tvar octave = 0, noteNum = n, noteName, returnFlattened = returnFlattened || false;\r\n\t\t\tif (n > 23) {\r\n\t\t\t\t// noteNum is on octave 1 or more\r\n\t\t\t\toctave = Math.floor(n/12) - 1;\r\n\t\t\t\t// subtract number of octaves from noteNum\r\n\t\t\t\tnoteNum = n - octave * 12;\r\n\t\t\t}\r\n\r\n\t\t\t// get note name (c#, d, f# etc)\r\n\t\t\tnoteName = Util.midi_pitches_letter[noteNum];\r\n\t\t\t// Use flattened notes if requested (e.g. f# should be output as gb)\r\n\t\t\tif (returnFlattened && noteName.indexOf('#') > 0) {\r\n\t\t\t\tnoteName = Util.midi_flattened_notes[noteName];\r\n\t\t\t}\r\n\t\t\treturn noteName + octave;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Convert beats per minute (BPM) to microseconds per quarter note (MPQN).\r\n\t\t *\r\n\t\t * @param {number} bpm - A number in beats per minute.\r\n\t\t * @returns {number} The number of microseconds per quarter note.\r\n\t\t */\r\n\t\tmpqnFromBpm: function(bpm) {\r\n\t\t\tvar mpqn = Math.floor(60000000 / bpm);\r\n\t\t\tvar ret=[];\r\n\t\t\tdo {\r\n\t\t\t\tret.unshift(mpqn & 0xFF);\r\n\t\t\t\tmpqn >>= 8;\r\n\t\t\t} while (mpqn);\r\n\t\t\twhile (ret.length < 3) {\r\n\t\t\t\tret.push(0);\r\n\t\t\t}\r\n\t\t\treturn ret;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Convert microseconds per quarter note (MPQN) to beats per minute (BPM).\r\n\t\t *\r\n\t\t * @param {number} mpqn - The number of microseconds per quarter note.\r\n\t\t * @returns {number} A number in beats per minute.\r\n\t\t */\r\n\t\tbpmFromMpqn: function(mpqn) {\r\n\t\t\tvar m = mpqn;\r\n\t\t\tif (typeof mpqn[0] != 'undefined') {\r\n\t\t\t\tm = 0;\r\n\t\t\t\tfor (var i=0, l=mpqn.length-1; l >= 0; ++i, --l) {\r\n\t\t\t\t\tm |= mpqn[i] << l;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Math.floor(60000000 / mpqn);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Converts an array of bytes to a string of hexadecimal characters. Prepares\r\n\t\t * it to be converted into a base64 string.\r\n\t\t *\r\n\t\t * @param {Array} byteArray - Array of bytes to be converted.\r\n\t\t * @returns {string} Hexadecimal string, e.g. \"097B8A\".\r\n\t\t */\r\n\t\tcodes2Str: function(byteArray) {\r\n\t\t\treturn String.fromCharCode.apply(null, byteArray);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Converts a string of hexadecimal values to an array of bytes. It can also\r\n\t\t * add remaining \"0\" nibbles in order to have enough bytes in the array as the\r\n\t\t * `finalBytes` parameter.\r\n\t\t *\r\n\t\t * @param {string} str - string of hexadecimal values e.g. \"097B8A\"\r\n\t\t * @param {number} [finalBytes] - Optional. The desired number of bytes\r\n\t\t * (not nibbles) that the returned array should contain.\r\n\t\t * @returns {Array} An array of nibbles.\r\n\t\t */\r\n\t\tstr2Bytes: function (str, finalBytes) {\r\n\t\t\tif (finalBytes) {\r\n\t\t\t\twhile ((str.length / 2) < finalBytes) { str = \"0\" + str; }\r\n\t\t\t}\r\n\r\n\t\t\tvar bytes = [];\r\n\t\t\tfor (var i=str.length-1; i>=0; i = i-2) {\r\n\t\t\t\tvar chars = i === 0 ? str[i] : str[i-1] + str[i];\r\n\t\t\t\tbytes.unshift(parseInt(chars, 16));\r\n\t\t\t}\r\n\r\n\t\t\treturn bytes;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Translates number of ticks to MIDI timestamp format, returning an array\r\n\t\t * of bytes with the time values. MIDI has a very particular way to express\r\n\t\t * time; take a good look at the spec before ever touching this function.\r\n\t\t *\r\n\t\t * @param {number} ticks - Number of ticks to be translated.\r\n\t\t * @returns {number} Array of bytes that form the MIDI time value.\r\n\t\t */\r\n\t\ttranslateTickTime: function(ticks) {\r\n\t\t\tvar buffer = ticks & 0x7F;\r\n\r\n\t\t\twhile (ticks = ticks >> 7) {\r\n\t\t\t\tbuffer <<= 8;\r\n\t\t\t\tbuffer |= ((ticks & 0x7F) | 0x80);\r\n\t\t\t}\r\n\r\n\t\t\tvar bList = [];\r\n\t\t\twhile (true) {\r\n\t\t\t\tbList.push(buffer & 0xff);\r\n\r\n\t\t\t\tif (buffer & 0x80) { buffer >>= 8; }\r\n\t\t\t\telse { break; }\r\n\t\t\t}\r\n\t\t\treturn bList;\r\n\t\t},\r\n\r\n\t};\r\n\r\n\t/* ******************************************************************\r\n\t * Event class\r\n\t ****************************************************************** */\r\n\r\n\t/**\r\n\t * Construct a MIDI event.\r\n\t *\r\n\t * Parameters include:\r\n\t *  - time [optional number] - Ticks since previous event.\r\n\t *  - type [required number] - Type of event.\r\n\t *  - channel [required number] - Channel for the event.\r\n\t *  - param1 [required number] - First event parameter.\r\n\t *  - param2 [optional number] - Second event parameter.\r\n\t */\r\n\tvar MidiEvent = function(params) {\r\n\t\tif (!this) return new MidiEvent(params);\r\n\t\tif (params &&\r\n\t\t\t\t(params.type    !== null || params.type    !== undefined) &&\r\n\t\t\t\t(params.channel !== null || params.channel !== undefined) &&\r\n\t\t\t\t(params.param1  !== null || params.param1  !== undefined)) {\r\n\t\t\tthis.setTime(params.time);\r\n\t\t\tthis.setType(params.type);\r\n\t\t\tthis.setChannel(params.channel);\r\n\t\t\tthis.setParam1(params.param1);\r\n\t\t\tthis.setParam2(params.param2);\r\n\t\t}\r\n\t};\r\n\r\n\t// event codes\r\n\tMidiEvent.NOTE_OFF           = 0x80;\r\n\tMidiEvent.NOTE_ON            = 0x90;\r\n\tMidiEvent.AFTER_TOUCH        = 0xA0;\r\n\tMidiEvent.CONTROLLER         = 0xB0;\r\n\tMidiEvent.PROGRAM_CHANGE     = 0xC0;\r\n\tMidiEvent.CHANNEL_AFTERTOUCH = 0xD0;\r\n\tMidiEvent.PITCH_BEND         = 0xE0;\r\n\r\n\r\n\t/**\r\n\t * Set the time for the event in ticks since the previous event.\r\n\t *\r\n\t * @param {number} ticks - The number of ticks since the previous event. May\r\n\t * be zero.\r\n\t */\r\n\tMidiEvent.prototype.setTime = function(ticks) {\r\n\t\tthis.time = Util.translateTickTime(ticks || 0);\r\n\t};\r\n\r\n\t/**\r\n\t * Set the type of the event. Must be one of the event codes on MidiEvent.\r\n\t *\r\n\t * @param {number} type - Event type.\r\n\t */\r\n\tMidiEvent.prototype.setType = function(type) {\r\n\t\tif (type < MidiEvent.NOTE_OFF || type > MidiEvent.PITCH_BEND) {\r\n\t\t\tthrow new Error(\"Trying to set an unknown event: \" + type);\r\n\t\t}\r\n\r\n\t\tthis.type = type;\r\n\t};\r\n\r\n\t/**\r\n\t * Set the channel for the event. Must be between 0 and 15, inclusive.\r\n\t *\r\n\t * @param {number} channel - The event channel.\r\n\t */\r\n\tMidiEvent.prototype.setChannel = function(channel) {\r\n\t\tif (channel < 0 || channel > 15) {\r\n\t\t\tthrow new Error(\"Channel is out of bounds.\");\r\n\t\t}\r\n\r\n\t\tthis.channel = channel;\r\n\t};\r\n\r\n\t/**\r\n\t * Set the first parameter for the event. Must be between 0 and 255,\r\n\t * inclusive.\r\n\t *\r\n\t * @param {number} p - The first event parameter value.\r\n\t */\r\n\tMidiEvent.prototype.setParam1 = function(p) {\r\n\t\tthis.param1 = p;\r\n\t};\r\n\r\n\t/**\r\n\t * Set the second parameter for the event. Must be between 0 and 255,\r\n\t * inclusive.\r\n\t *\r\n\t * @param {number} p - The second event parameter value.\r\n\t */\r\n\tMidiEvent.prototype.setParam2 = function(p) {\r\n\t\tthis.param2 = p;\r\n\t};\r\n\r\n\t/**\r\n\t * Serialize the event to an array of bytes.\r\n\t *\r\n\t * @returns {Array} The array of serialized bytes.\r\n\t */\r\n\tMidiEvent.prototype.toBytes = function() {\r\n\t\tvar byteArray = [];\r\n\r\n\t\tvar typeChannelByte = this.type | (this.channel & 0xF);\r\n\r\n\t\tbyteArray.push.apply(byteArray, this.time);\r\n\t\tbyteArray.push(typeChannelByte);\r\n\t\tbyteArray.push(this.param1);\r\n\r\n\t\t// Some events don't have a second parameter\r\n\t\tif (this.param2 !== undefined && this.param2 !== null) {\r\n\t\t\tbyteArray.push(this.param2);\r\n\t\t}\r\n\t\treturn byteArray;\r\n\t};\r\n\r\n\t/* ******************************************************************\r\n\t * MetaEvent class\r\n\t ****************************************************************** */\r\n\r\n\t/**\r\n\t * Construct a meta event.\r\n\t *\r\n\t * Parameters include:\r\n\t *  - time [optional number] - Ticks since previous event.\r\n\t *  - type [required number] - Type of event.\r\n\t *  - data [optional array|string] - Event data.\r\n\t */\r\n\tvar MetaEvent = function(params) {\r\n\t\tif (!this) return new MetaEvent(params);\r\n\t\tvar p = params || {};\r\n\t\tthis.setTime(params.time);\r\n\t\tthis.setType(params.type);\r\n\t\tthis.setData(params.data);\r\n\t};\r\n\r\n\tMetaEvent.SEQUENCE   = 0x00;\r\n\tMetaEvent.TEXT       = 0x01;\r\n\tMetaEvent.COPYRIGHT  = 0x02;\r\n\tMetaEvent.TRACK_NAME = 0x03;\r\n\tMetaEvent.INSTRUMENT = 0x04;\r\n\tMetaEvent.LYRIC      = 0x05;\r\n\tMetaEvent.MARKER     = 0x06;\r\n\tMetaEvent.CUE_POINT  = 0x07;\r\n\tMetaEvent.CHANNEL_PREFIX = 0x20;\r\n\tMetaEvent.END_OF_TRACK   = 0x2f;\r\n\tMetaEvent.TEMPO      = 0x51;\r\n\tMetaEvent.SMPTE      = 0x54;\r\n\tMetaEvent.TIME_SIG   = 0x58;\r\n\tMetaEvent.KEY_SIG    = 0x59;\r\n\tMetaEvent.SEQ_EVENT  = 0x7f;\r\n\r\n\t/**\r\n\t * Set the time for the event in ticks since the previous event.\r\n\t *\r\n\t * @param {number} ticks - The number of ticks since the previous event. May\r\n\t * be zero.\r\n\t */\r\n\tMetaEvent.prototype.setTime = function(ticks) {\r\n\t\tthis.time = Util.translateTickTime(ticks || 0);\r\n\t};\r\n\r\n\t/**\r\n\t * Set the type of the event. Must be one of the event codes on MetaEvent.\r\n\t *\r\n\t * @param {number} t - Event type.\r\n\t */\r\n\tMetaEvent.prototype.setType = function(t) {\r\n\t\tthis.type = t;\r\n\t};\r\n\r\n\t/**\r\n\t * Set the data associated with the event. May be a string or array of byte\r\n\t * values.\r\n\t *\r\n\t * @param {string|Array} d - Event data.\r\n\t */\r\n\tMetaEvent.prototype.setData = function(d) {\r\n\t\tthis.data = d;\r\n\t};\r\n\r\n\t/**\r\n\t * Serialize the event to an array of bytes.\r\n\t *\r\n\t * @returns {Array} The array of serialized bytes.\r\n\t */\r\n\tMetaEvent.prototype.toBytes = function() {\r\n\t\tif (!this.type) {\r\n\t\t\tthrow new Error(\"Type for meta-event not specified.\");\r\n\t\t}\r\n\r\n\t\tvar byteArray = [];\r\n\t\tbyteArray.push.apply(byteArray, this.time);\r\n\t\tbyteArray.push(0xFF, this.type);\r\n\r\n\t\t// If data is an array, we assume that it contains several bytes. We\r\n\t\t// apend them to byteArray.\r\n\t\tif (Array.isArray(this.data)) {\r\n\t\t\tbyteArray.push(this.data.length);\r\n\t\t\tbyteArray.push.apply(byteArray, this.data);\r\n\t\t} else if (typeof this.data == 'number') {\r\n\t\t\tbyteArray.push(1, this.data);\r\n\t\t} else if (this.data !== null && this.data !== undefined) {\r\n\t\t\t// assume string; may be a bad assumption\r\n\t\t\tbyteArray.push(this.data.length);\r\n\t\t\tvar dataBytes = this.data.split('').map(function(x){ return x.charCodeAt(0) });\r\n\t\t\tbyteArray.push.apply(byteArray, dataBytes);\r\n\t\t} else {\r\n\t\t\tbyteArray.push(0);\r\n\t\t}\r\n\r\n\t\treturn byteArray;\r\n\t};\r\n\r\n\t/* ******************************************************************\r\n\t * Track class\r\n\t ****************************************************************** */\r\n\r\n\t/**\r\n\t * Construct a MIDI track.\r\n\t *\r\n\t * Parameters include:\r\n\t *  - events [optional array] - Array of events for the track.\r\n\t */\r\n\tvar Track = function(config) {\r\n\t\tif (!this) return new Track(config);\r\n\t\tvar c = config || {};\r\n\t\tthis.events = c.events || [];\r\n\t};\r\n\r\n\tTrack.START_BYTES = [0x4d, 0x54, 0x72, 0x6b];\r\n\tTrack.END_BYTES   = [0x00, 0xFF, 0x2F, 0x00];\r\n\r\n\t/**\r\n\t * Add an event to the track.\r\n\t *\r\n\t * @param {MidiEvent|MetaEvent} event - The event to add.\r\n\t * @returns {Track} The current track.\r\n\t */\r\n\tTrack.prototype.addEvent = function(event) {\r\n\t\tthis.events.push(event);\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * Add a note-on event to the track.\r\n\t *\r\n\t * @param {number} channel - The channel to add the event to.\r\n\t * @param {number|string} pitch - The pitch of the note, either numeric or\r\n\t * symbolic.\r\n\t * @param {number} [time=0] - The number of ticks since the previous event,\r\n\t * defaults to 0.\r\n\t * @param {number} [velocity=90] - The volume for the note, defaults to\r\n\t * DEFAULT_VOLUME.\r\n\t * @returns {Track} The current track.\r\n\t */\r\n\tTrack.prototype.addNoteOn = Track.prototype.noteOn = function(channel, pitch, time, velocity) {\r\n\t\tthis.events.push(new MidiEvent({\r\n\t\t\ttype: MidiEvent.NOTE_ON,\r\n\t\t\tchannel: channel,\r\n\t\t\tparam1: Util.ensureMidiPitch(pitch),\r\n\t\t\tparam2: velocity || DEFAULT_VOLUME,\r\n\t\t\ttime: time || 0,\r\n\t\t}));\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * Add a note-off event to the track.\r\n\t *\r\n\t * @param {number} channel - The channel to add the event to.\r\n\t * @param {number|string} pitch - The pitch of the note, either numeric or\r\n\t * symbolic.\r\n\t * @param {number} [time=0] - The number of ticks since the previous event,\r\n\t * defaults to 0.\r\n\t * @param {number} [velocity=90] - The velocity the note was released,\r\n\t * defaults to DEFAULT_VOLUME.\r\n\t * @returns {Track} The current track.\r\n\t */\r\n\tTrack.prototype.addNoteOff = Track.prototype.noteOff = function(channel, pitch, time, velocity) {\r\n\t\tthis.events.push(new MidiEvent({\r\n\t\t\ttype: MidiEvent.NOTE_OFF,\r\n\t\t\tchannel: channel,\r\n\t\t\tparam1: Util.ensureMidiPitch(pitch),\r\n\t\t\tparam2: velocity || DEFAULT_VOLUME,\r\n\t\t\ttime: time || 0,\r\n\t\t}));\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * Add a note-on and -off event to the track.\r\n\t *\r\n\t * @param {number} channel - The channel to add the event to.\r\n\t * @param {number|string} pitch - The pitch of the note, either numeric or\r\n\t * symbolic.\r\n\t * @param {number} dur - The duration of the note, in ticks.\r\n\t * @param {number} [time=0] - The number of ticks since the previous event,\r\n\t * defaults to 0.\r\n\t * @param {number} [velocity=90] - The velocity the note was released,\r\n\t * defaults to DEFAULT_VOLUME.\r\n\t * @returns {Track} The current track.\r\n\t */\r\n\tTrack.prototype.addNote = Track.prototype.note = function(channel, pitch, dur, time, velocity) {\r\n\t\tthis.noteOn(channel, pitch, time, velocity);\r\n\t\tif (dur) {\r\n\t\t\tthis.noteOff(channel, pitch, dur, velocity);\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * Add a note-on and -off event to the track for each pitch in an array of pitches.\r\n\t *\r\n\t * @param {number} channel - The channel to add the event to.\r\n\t * @param {array} chord - An array of pitches, either numeric or\r\n\t * symbolic.\r\n\t * @param {number} dur - The duration of the chord, in ticks.\r\n\t * @param {number} [velocity=90] - The velocity of the chord,\r\n\t * defaults to DEFAULT_VOLUME.\r\n\t * @returns {Track} The current track.\r\n\t */\r\n\tTrack.prototype.addChord = Track.prototype.chord = function(channel, chord, dur, velocity) {\r\n\t\tif (!Array.isArray(chord) && !chord.length) {\r\n\t\t\tthrow new Error('Chord must be an array of pitches');\r\n\t\t}\r\n\t\tchord.forEach(function(note) {\r\n\t\t\tthis.noteOn(channel, note, 0, velocity);\r\n\t\t}, this);\r\n\t\tchord.forEach(function(note, index) {\r\n\t\t\tif (index === 0) {\r\n\t\t\t\tthis.noteOff(channel, note, dur);\r\n\t\t\t} else {\r\n\t\t\t\tthis.noteOff(channel, note);\r\n\t\t\t}\r\n\t\t}, this);\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * Set instrument for the track.\r\n\t *\r\n\t * @param {number} channel - The channel to set the instrument on.\r\n\t * @param {number} instrument - The instrument to set it to.\r\n\t * @param {number} [time=0] - The number of ticks since the previous event,\r\n\t * defaults to 0.\r\n\t * @returns {Track} The current track.\r\n\t */\r\n\tTrack.prototype.setInstrument = Track.prototype.instrument = function(channel, instrument, time) {\r\n\t\tthis.events.push(new MidiEvent({\r\n\t\t\ttype: MidiEvent.PROGRAM_CHANGE,\r\n\t\t\tchannel: channel,\r\n\t\t\tparam1: instrument,\r\n\t\t\ttime: time || 0,\r\n\t\t}));\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * Set the tempo for the track.\r\n\t *\r\n\t * @param {number} bpm - The new number of beats per minute.\r\n\t * @param {number} [time=0] - The number of ticks since the previous event,\r\n\t * defaults to 0.\r\n\t * @returns {Track} The current track.\r\n\t */\r\n\tTrack.prototype.setTempo = Track.prototype.tempo = function(bpm, time) {\r\n\t\tthis.events.push(new MetaEvent({\r\n\t\t\ttype: MetaEvent.TEMPO,\r\n\t\t\tdata: Util.mpqnFromBpm(bpm),\r\n\t\t\ttime: time || 0,\r\n\t\t}));\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * Serialize the track to an array of bytes.\r\n\t *\r\n\t * @returns {Array} The array of serialized bytes.\r\n\t */\r\n\tTrack.prototype.toBytes = function() {\r\n\t\tvar trackLength = 0;\r\n\t\tvar eventBytes = [];\r\n\t\tvar startBytes = Track.START_BYTES;\r\n\t\tvar endBytes   = Track.END_BYTES;\r\n\r\n\t\tvar addEventBytes = function(event) {\r\n\t\t\tvar bytes = event.toBytes();\r\n\t\t\ttrackLength += bytes.length;\r\n\t\t\teventBytes.push.apply(eventBytes, bytes);\r\n\t\t};\r\n\r\n\t\tthis.events.forEach(addEventBytes);\r\n\r\n\t\t// Add the end-of-track bytes to the sum of bytes for the track, since\r\n\t\t// they are counted (unlike the start-of-track ones).\r\n\t\ttrackLength += endBytes.length;\r\n\r\n\t\t// Makes sure that track length will fill up 4 bytes with 0s in case\r\n\t\t// the length is less than that (the usual case).\r\n\t\tvar lengthBytes = Util.str2Bytes(trackLength.toString(16), 4);\r\n\r\n\t\treturn startBytes.concat(lengthBytes, eventBytes, endBytes);\r\n\t};\r\n\r\n\t/* ******************************************************************\r\n\t * File class\r\n\t ****************************************************************** */\r\n\r\n\t/**\r\n\t * Construct a file object.\r\n\t *\r\n\t * Parameters include:\r\n\t *  - ticks [optional number] - Number of ticks per beat, defaults to 128.\r\n\t *    Must be 1-32767.\r\n\t *  - tracks [optional array] - Track data.\r\n\t */\r\n\tvar File = function(config){\r\n\t\tif (!this) return new File(config);\r\n\r\n\t\tvar c = config || {};\r\n\t\tif (c.ticks) {\r\n\t\t\tif (typeof c.ticks !== 'number') {\r\n\t\t\t\tthrow new Error('Ticks per beat must be a number!');\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (c.ticks <= 0 || c.ticks >= (1 << 15) || c.ticks % 1 !== 0) {\r\n\t\t\t\tthrow new Error('Ticks per beat must be an integer between 1 and 32767!');\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.ticks = c.ticks || 128;\r\n\t\tthis.tracks = c.tracks || [];\r\n\t};\r\n\r\n\tFile.HDR_CHUNKID     = \"MThd\";             // File magic cookie\r\n\tFile.HDR_CHUNK_SIZE  = \"\\x00\\x00\\x00\\x06\"; // Header length for SMF\r\n\tFile.HDR_TYPE0       = \"\\x00\\x00\";         // Midi Type 0 id\r\n\tFile.HDR_TYPE1       = \"\\x00\\x01\";         // Midi Type 1 id\r\n\r\n\t/**\r\n\t * Add a track to the file.\r\n\t *\r\n\t * @param {Track} track - The track to add.\r\n\t */\r\n\tFile.prototype.addTrack = function(track) {\r\n\t\tif (track) {\r\n\t\t\tthis.tracks.push(track);\r\n\t\t\treturn this;\r\n\t\t} else {\r\n\t\t\ttrack = new Track();\r\n\t\t\tthis.tracks.push(track);\r\n\t\t\treturn track;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Serialize the MIDI file to an array of bytes.\r\n\t *\r\n\t * @returns {Array} The array of serialized bytes.\r\n\t */\r\n\tFile.prototype.toBytes = function() {\r\n\t\tvar trackCount = this.tracks.length.toString(16);\r\n\r\n\t\t// prepare the file header\r\n\t\tvar bytes = File.HDR_CHUNKID + File.HDR_CHUNK_SIZE;\r\n\r\n\t\t// set Midi type based on number of tracks\r\n\t\tif (parseInt(trackCount, 16) > 1) {\r\n\t\t\tbytes += File.HDR_TYPE1;\r\n\t\t} else {\r\n\t\t\tbytes += File.HDR_TYPE0;\r\n\t\t}\r\n\r\n\t\t// add the number of tracks (2 bytes)\r\n\t\tbytes += Util.codes2Str(Util.str2Bytes(trackCount, 2));\r\n\t\t// add the number of ticks per beat (currently hardcoded)\r\n\t\tbytes += String.fromCharCode((this.ticks/256),  this.ticks%256);;\r\n\r\n\t\t// iterate over the tracks, converting to bytes too\r\n\t\tthis.tracks.forEach(function(track) {\r\n\t\t\tbytes += Util.codes2Str(track.toBytes());\r\n\t\t});\r\n\r\n\t\treturn bytes;\r\n\t};\r\n\r\n\t/* ******************************************************************\r\n\t * Exports\r\n\t ****************************************************************** */\r\n\r\n\texported.Util = Util;\r\n\texported.File = File;\r\n\texported.Track = Track;\r\n\texported.Event = MidiEvent;\r\n\texported.MetaEvent = MetaEvent;\r\n\r\n})( Midi );\r\n\r\nif ( true && module !== null) {\r\n\tmodule.exports = Midi;\r\n} else if ( true && exports !== null) {\r\n\texports = Midi;\r\n} else {\r\n\tthis.Midi = Midi;\r\n}\r\n\n\n//# sourceURL=webpack://Synthesizer/./src/js/jsmidgen.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/jsmidgen.js");
/******/ 	
/******/ })()
;