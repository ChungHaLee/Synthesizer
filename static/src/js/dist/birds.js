/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/vanta/src/_base.js":
/*!*****************************************!*\
  !*** ./node_modules/vanta/src/_base.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VANTA\": () => (/* binding */ VANTA),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/vanta/src/helpers.js\");\n\r\n// const DEBUGMODE = window.location.toString().indexOf('VANTADEBUG') !== -1\r\n\r\nconst win = typeof window == 'object'\r\nlet THREE = (win && window.THREE) || {}\r\nif (win && !window.VANTA) window.VANTA = {}\r\nconst VANTA = (win && window.VANTA) || {}\r\nVANTA.register = (name, Effect) => {\r\n  return VANTA[name] = (opts) => new Effect(opts)\r\n}\r\nVANTA.version = '0.5.24'\r\n\r\n\r\n\r\n// const ORBITCONTROLS = {\r\n//   enableZoom: false,\r\n//   userPanSpeed: 3,\r\n//   userRotateSpeed: 2.0,\r\n//   maxPolarAngle: Math.PI * 0.8, // (pi/2 is pure horizontal)\r\n//   mouseButtons: {\r\n//     ORBIT: THREE.MOUSE.LEFT,\r\n//     ZOOM: null,\r\n//     PAN: null\r\n//   }\r\n// }\r\n// if (DEBUGMODE) {\r\n//   Object.assign(ORBITCONTROLS, {\r\n//     enableZoom: true,\r\n//     zoomSpeed: 4,\r\n//     minDistance: 100,\r\n//     maxDistance: 4500\r\n//   })\r\n// }\r\n\r\n// Namespace for errors\r\nconst error = function() {\r\n  Array.prototype.unshift.call(arguments, '[VANTA]')\r\n  return console.error.apply(this, arguments)\r\n}\r\n\r\nVANTA.VantaBase = class VantaBase {\r\n  constructor(userOptions = {}) {\r\n    if (!win) return false\r\n    VANTA.current = this\r\n    this.windowMouseMoveWrapper = this.windowMouseMoveWrapper.bind(this)\r\n    this.windowTouchWrapper = this.windowTouchWrapper.bind(this)\r\n    this.windowGyroWrapper = this.windowGyroWrapper.bind(this)\r\n    this.resize = this.resize.bind(this)\r\n    this.animationLoop = this.animationLoop.bind(this)\r\n    this.restart = this.restart.bind(this)\r\n\r\n    const defaultOptions = (typeof this.getDefaultOptions === 'function') ? this.getDefaultOptions() : this.defaultOptions\r\n    this.options = Object.assign({\r\n      mouseControls: true,\r\n      touchControls: true,\r\n      gyroControls: false,\r\n      minHeight: 200,\r\n      minWidth: 200,\r\n      scale: 1,\r\n      scaleMobile: 1,\r\n    }, defaultOptions)\r\n\r\n    if (userOptions instanceof HTMLElement || typeof userOptions === 'string') {\r\n      userOptions = {el: userOptions}\r\n    }\r\n    Object.assign(this.options, userOptions)\r\n\r\n    if (this.options.THREE) {\r\n      THREE = this.options.THREE // Optionally use a custom build of three.js\r\n    }\r\n\r\n    // Set element\r\n    this.el = this.options.el\r\n    if (this.el == null) {\r\n      error(\"Instance needs \\\"el\\\" param!\")\r\n    } else if (!(this.options.el instanceof HTMLElement)) {\r\n      const selector = this.el\r\n      this.el = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.q)(selector)\r\n      if (!this.el) {\r\n        error(\"Cannot find element\", selector)\r\n        return\r\n      }\r\n    }\r\n\r\n    this.prepareEl()\r\n    this.initThree()\r\n    this.setSize() // Init needs size\r\n\r\n    try {\r\n      this.init()\r\n    } catch (e) {\r\n      // FALLBACK - just use color\r\n      error('Init error', e)\r\n      if (this.renderer && this.renderer.domElement) {\r\n        this.el.removeChild(this.renderer.domElement)\r\n      }\r\n      if (this.options.backgroundColor) {\r\n        console.log('[VANTA] Falling back to backgroundColor')\r\n        this.el.style.background = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.color2Hex)(this.options.backgroundColor)\r\n      }\r\n      return\r\n    }\r\n\r\n    // After init\r\n    this.initMouse() // Triggers mouse, which needs to be called after init\r\n    this.resize()\r\n    this.animationLoop()\r\n\r\n    // Event listeners\r\n    const ad = window.addEventListener\r\n    ad('resize', this.resize)\r\n    window.requestAnimationFrame(this.resize) // Force a resize after the first frame\r\n\r\n    // Add event listeners on window, because this element may be below other elements, which would block the element's own mousemove event\r\n    if (this.options.mouseControls) {\r\n      ad('scroll', this.windowMouseMoveWrapper)\r\n      ad('mousemove', this.windowMouseMoveWrapper)\r\n    }\r\n    if (this.options.touchControls) {\r\n      ad('touchstart', this.windowTouchWrapper)\r\n      ad('touchmove', this.windowTouchWrapper)\r\n    }\r\n    if (this.options.gyroControls) {\r\n      ad('deviceorientation', this.windowGyroWrapper)\r\n    }\r\n  }\r\n\r\n  setOptions(userOptions={}){\r\n    Object.assign(this.options, userOptions)\r\n    this.triggerMouseMove()\r\n  }\r\n\r\n  prepareEl() {\r\n    let i, child\r\n    // wrapInner for text nodes, so text nodes can be put into foreground\r\n    if (typeof Node !== 'undefined' && Node.TEXT_NODE) {\r\n      for (i = 0; i < this.el.childNodes.length; i++) {\r\n        const n = this.el.childNodes[i]\r\n        if (n.nodeType === Node.TEXT_NODE) {\r\n          const s = document.createElement('span')\r\n          s.textContent = n.textContent\r\n          n.parentElement.insertBefore(s, n)\r\n          n.remove()\r\n        }\r\n      }\r\n    }\r\n    // Set foreground elements\r\n    for (i = 0; i < this.el.children.length; i++) {\r\n      child = this.el.children[i]\r\n      if (getComputedStyle(child).position === 'static') {\r\n        child.style.position = 'relative'\r\n      }\r\n      if (getComputedStyle(child).zIndex === 'auto') {\r\n        child.style.zIndex = 1\r\n      }\r\n    }\r\n    // Set canvas and container style\r\n    if (getComputedStyle(this.el).position === 'static') {\r\n      this.el.style.position = 'relative'\r\n    }\r\n  }\r\n\r\n  applyCanvasStyles(canvasEl, opts={}){\r\n    Object.assign(canvasEl.style, {\r\n      position: 'absolute',\r\n      zIndex: 0,\r\n      top: 0,\r\n      left: 0,\r\n      background: ''\r\n    })\r\n    Object.assign(canvasEl.style, opts)\r\n    canvasEl.classList.add('vanta-canvas')\r\n  }\r\n\r\n  initThree() {\r\n    if (!THREE.WebGLRenderer) {\r\n      console.warn(\"[VANTA] No THREE defined on window\")\r\n      return\r\n    }\r\n    // Set renderer\r\n    this.renderer = new THREE.WebGLRenderer({\r\n      alpha: true,\r\n      antialias: true\r\n    })\r\n    this.el.appendChild(this.renderer.domElement)\r\n    this.applyCanvasStyles(this.renderer.domElement)\r\n    if (isNaN(this.options.backgroundAlpha)) {\r\n      this.options.backgroundAlpha = 1\r\n    }\r\n\r\n    this.scene = new THREE.Scene()\r\n  }\r\n\r\n  getCanvasElement() {\r\n    if (this.renderer) {\r\n      return this.renderer.domElement // three.js\r\n    }\r\n    if (this.p5renderer) {\r\n      return this.p5renderer.canvas // p5\r\n    }\r\n  }\r\n\r\n  getCanvasRect() {\r\n    const canvas = this.getCanvasElement()\r\n    if (!canvas) return false\r\n    return canvas.getBoundingClientRect()\r\n  }\r\n\r\n  windowMouseMoveWrapper(e){\r\n    const rect = this.getCanvasRect()\r\n    if (!rect) return false\r\n    const x = e.clientX - rect.left\r\n    const y = e.clientY - rect.top\r\n    if (x>=0 && y>=0 && x<=rect.width && y<=rect.height) {\r\n      this.mouseX = x\r\n      this.mouseY = y\r\n      if (!this.options.mouseEase) this.triggerMouseMove(x, y)\r\n    }\r\n  }\r\n  windowTouchWrapper(e){\r\n    const rect = this.getCanvasRect()\r\n    if (!rect) return false\r\n    if (e.touches.length === 1) {\r\n      const x = e.touches[0].clientX - rect.left\r\n      const y = e.touches[0].clientY - rect.top\r\n      if (x>=0 && y>=0 && x<=rect.width && y<=rect.height) {\r\n        this.mouseX = x\r\n        this.mouseY = y\r\n        if (!this.options.mouseEase) this.triggerMouseMove(x, y)\r\n      }\r\n    }\r\n  }\r\n  windowGyroWrapper(e){\r\n    const rect = this.getCanvasRect()\r\n    if (!rect) return false\r\n    const x = Math.round(e.alpha * 2) - rect.left\r\n    const y = Math.round(e.beta * 2) - rect.top\r\n    if (x>=0 && y>=0 && x<=rect.width && y<=rect.height) {\r\n      this.mouseX = x\r\n      this.mouseY = y\r\n      if (!this.options.mouseEase) this.triggerMouseMove(x, y)\r\n    }\r\n  }\r\n\r\n  triggerMouseMove(x, y) {\r\n    if (x === undefined && y === undefined) { // trigger at current position\r\n      if (this.options.mouseEase) {\r\n        x = this.mouseEaseX\r\n        y = this.mouseEaseY\r\n      } else {\r\n        x = this.mouseX\r\n        y = this.mouseY\r\n      }\r\n    }\r\n    if (this.uniforms) {\r\n      this.uniforms.iMouse.value.x = x / this.scale // pixel values\r\n      this.uniforms.iMouse.value.y = y / this.scale // pixel values\r\n    }\r\n    const xNorm = x / this.width // 0 to 1\r\n    const yNorm = y / this.height // 0 to 1\r\n    typeof this.onMouseMove === \"function\" ? this.onMouseMove(xNorm, yNorm) : void 0\r\n  }\r\n\r\n  setSize() {\r\n    this.scale || (this.scale = 1)\r\n    if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.mobileCheck)() && this.options.scaleMobile) {\r\n      this.scale = this.options.scaleMobile\r\n    } else if (this.options.scale) {\r\n      this.scale = this.options.scale\r\n    }\r\n    this.width = Math.max(this.el.offsetWidth, this.options.minWidth)\r\n    this.height = Math.max(this.el.offsetHeight, this.options.minHeight)\r\n  }\r\n  initMouse() {\r\n    // Init mouseX and mouseY\r\n    if ((!this.mouseX && !this.mouseY) ||\r\n      (this.mouseX === this.options.minWidth/2 && this.mouseY === this.options.minHeight/2)) {\r\n      this.mouseX = this.width/2\r\n      this.mouseY = this.height/2\r\n      this.triggerMouseMove(this.mouseX, this.mouseY)\r\n    }\r\n  }\r\n\r\n  resize() {\r\n    this.setSize()\r\n    if (this.camera) {\r\n      this.camera.aspect = this.width / this.height\r\n      if (typeof this.camera.updateProjectionMatrix === \"function\") {\r\n        this.camera.updateProjectionMatrix()\r\n      }\r\n    }\r\n    if (this.renderer) {\r\n      this.renderer.setSize(this.width, this.height)\r\n      this.renderer.setPixelRatio(window.devicePixelRatio / this.scale)\r\n    }\r\n    typeof this.onResize === \"function\" ? this.onResize() : void 0\r\n  }\r\n\r\n  isOnScreen() {\r\n    const elHeight = this.el.offsetHeight\r\n    const elRect = this.el.getBoundingClientRect()\r\n    const scrollTop = (window.pageYOffset ||\r\n      (document.documentElement || document.body.parentNode || document.body).scrollTop\r\n    )\r\n    const offsetTop = elRect.top + scrollTop\r\n    const minScrollTop = offsetTop - window.innerHeight\r\n    const maxScrollTop = offsetTop + elHeight\r\n    return minScrollTop <= scrollTop && scrollTop <= maxScrollTop\r\n  }\r\n\r\n  animationLoop() {\r\n    // Step time\r\n    this.t || (this.t = 0)\r\n    // Uniform time\r\n    this.t2 || (this.t2 = 0)\r\n\r\n    // Normalize animation speed to 60fps\r\n    const now = performance.now()\r\n    if (this.prevNow) {\r\n      let elapsedTime = (now-this.prevNow) / (1000/60)\r\n      elapsedTime = Math.max(0.2, Math.min(elapsedTime, 5))\r\n      this.t += elapsedTime\r\n\r\n      this.t2 += (this.options.speed || 1) * elapsedTime\r\n      if (this.uniforms) {\r\n        this.uniforms.iTime.value = this.t2 * 0.016667 // iTime is in seconds\r\n      }\r\n    }\r\n    this.prevNow = now\r\n\r\n\r\n    if (this.options.mouseEase) {\r\n      this.mouseEaseX = this.mouseEaseX || this.mouseX || 0\r\n      this.mouseEaseY = this.mouseEaseY || this.mouseY || 0\r\n      if (Math.abs(this.mouseEaseX-this.mouseX) + Math.abs(this.mouseEaseY-this.mouseY) > 0.1) {\r\n        this.mouseEaseX += (this.mouseX - this.mouseEaseX) * 0.05\r\n        this.mouseEaseY += (this.mouseY - this.mouseEaseY) * 0.05\r\n        this.triggerMouseMove(this.mouseEaseX, this.mouseEaseY)\r\n      }\r\n    }\r\n\r\n    // Only animate if element is within view\r\n    if (this.isOnScreen() || this.options.forceAnimate) {\r\n      if (typeof this.onUpdate === \"function\") {\r\n        this.onUpdate()\r\n      }\r\n      if (this.scene && this.camera) {\r\n        this.renderer.render(this.scene, this.camera)\r\n        this.renderer.setClearColor(this.options.backgroundColor, this.options.backgroundAlpha)\r\n      }\r\n      // if (this.stats) this.stats.update()\r\n      // if (this.renderStats) this.renderStats.update(this.renderer)\r\n      if (this.fps && this.fps.update) this.fps.update()\r\n      if (typeof this.afterRender === \"function\") this.afterRender()\r\n    }\r\n    return this.req = window.requestAnimationFrame(this.animationLoop)\r\n  }\r\n\r\n  // setupControls() {\r\n  //   if (DEBUGMODE && THREE.OrbitControls) {\r\n  //     this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement)\r\n  //     Object.assign(this.controls, ORBITCONTROLS)\r\n  //     return this.scene.add(new THREE.AxisHelper(100))\r\n  //   }\r\n  // }\r\n\r\n  restart() {\r\n    // Restart the effect without destroying the renderer\r\n    if (this.scene) {\r\n      while (this.scene.children.length) {\r\n        this.scene.remove(this.scene.children[0])\r\n      }\r\n    }\r\n    if (typeof this.onRestart === \"function\") {\r\n      this.onRestart()\r\n    }\r\n    this.init()\r\n  }\r\n\r\n  init() {\r\n    if (typeof this.onInit === \"function\") {\r\n      this.onInit()\r\n    }\r\n    // this.setupControls()\r\n  }\r\n\r\n  destroy() {\r\n    if (typeof this.onDestroy === \"function\") {\r\n      this.onDestroy()\r\n    }\r\n    const rm = window.removeEventListener\r\n    rm('touchstart', this.windowTouchWrapper)\r\n    rm('touchmove', this.windowTouchWrapper)\r\n    rm('scroll', this.windowMouseMoveWrapper)\r\n    rm('mousemove', this.windowMouseMoveWrapper)\r\n    rm('deviceorientation', this.windowGyroWrapper)\r\n    rm('resize', this.resize)\r\n    window.cancelAnimationFrame(this.req)\r\n\r\n    const scene = this.scene\r\n    if (scene && scene.children) {\r\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.clearThree)(scene)\r\n    }\r\n    if (this.renderer) {\r\n      if (this.renderer.domElement) {\r\n        this.el.removeChild(this.renderer.domElement)\r\n      }\r\n      this.renderer = null\r\n      this.scene = null\r\n    }\r\n\r\n    if (VANTA.current === this) {\r\n      VANTA.current = null\r\n    }\r\n  }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VANTA.VantaBase);\n\n//# sourceURL=webpack://Synthesizer/./node_modules/vanta/src/_base.js?");

/***/ }),

/***/ "./node_modules/vanta/src/helpers.js":
/*!*******************************************!*\
  !*** ./node_modules/vanta/src/helpers.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"clearThree\": () => (/* binding */ clearThree),\n/* harmony export */   \"color2Hex\": () => (/* binding */ color2Hex),\n/* harmony export */   \"color2Rgb\": () => (/* binding */ color2Rgb),\n/* harmony export */   \"getBrightness\": () => (/* binding */ getBrightness),\n/* harmony export */   \"mobileCheck\": () => (/* binding */ mobileCheck),\n/* harmony export */   \"q\": () => (/* binding */ q),\n/* harmony export */   \"ri\": () => (/* binding */ ri),\n/* harmony export */   \"rn\": () => (/* binding */ rn),\n/* harmony export */   \"sample\": () => (/* binding */ sample)\n/* harmony export */ });\nNumber.prototype.clamp = function(min, max) { return Math.min(Math.max(this, min), max) }\r\n\r\n// # module.exports = helpers\r\n\r\nfunction mobileCheck(){\r\n  if (typeof navigator !== 'undefined') {\r\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 600\r\n  }\r\n  return null\r\n}\r\nconst sample = items => items[Math.floor(Math.random()*items.length)]\r\n\r\nfunction rn(start,end) {\r\n  if (start == null) start = 0\r\n  if (end == null) end = 1\r\n  return start + (Math.random() * (end - start))\r\n}\r\n\r\nfunction ri(start,end) {\r\n  if (start == null) start = 0\r\n  if (end == null) end = 1\r\n  return Math.floor(start + (Math.random() * ((end - start) + 1)))\r\n}\r\n\r\nconst q = sel => document.querySelector(sel)\r\n\r\nconst color2Hex = (color) => {\r\n  if (typeof color == 'number'){\r\n    return '#' +  ('00000' + color.toString(16)).slice(-6)\r\n  } else return color\r\n}\r\n\r\nconst color2Rgb = (color, alpha=1) => {\r\n  const hex = color2Hex(color)\r\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\r\n  const obj = result ? {\r\n      r: parseInt(result[1], 16),\r\n      g: parseInt(result[2], 16),\r\n      b: parseInt(result[3], 16)\r\n  } : null\r\n  return 'rgba('+ obj.r +','+ obj.g +','+ obj.b +','+ alpha +')'\r\n}\r\n\r\nconst getBrightness = (threeColor) => {\r\n  return (0.299 * threeColor.r) + (0.587 * threeColor.g) + (0.114 * threeColor.b);\r\n}\r\n\r\nfunction clearThree(obj) {\r\n  // https://stackoverflow.com/questions/30359830/how-do-i-clear-three-js-scene/48722282\r\n  while (obj.children && obj.children.length > 0) {\r\n    clearThree(obj.children[0])\r\n    obj.remove(obj.children[0])\r\n  }\r\n  if (obj.geometry) obj.geometry.dispose()\r\n  if (obj.material) { // in case of map, bumpMap, normalMap, envMap ...\r\n    Object.keys(obj.material).forEach(prop => {\r\n      if (!obj.material[prop]) return\r\n      if (obj.material[prop] !== null && typeof obj.material[prop].dispose === 'function') {\r\n        obj.material[prop].dispose()\r\n      }\r\n    })\r\n    obj.material.dispose()\r\n  }\r\n}\n\n//# sourceURL=webpack://Synthesizer/./node_modules/vanta/src/helpers.js?");

/***/ }),

/***/ "./node_modules/vanta/src/vanta.birds.js":
/*!***********************************************!*\
  !*** ./node_modules/vanta/src/vanta.birds.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_base.js */ \"./node_modules/vanta/src/_base.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/vanta/src/helpers.js\");\n/* harmony import */ var _vendor_GPUComputationRenderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../vendor/GPUComputationRenderer.js */ \"./node_modules/vanta/vendor/GPUComputationRenderer.js\");\n// Adapted from https://threejs.org/examples/canvas_geometry_birds.html\r\n\r\n\r\n// import {rn, ri, sample} from './helpers.js'\r\n\r\n\r\n\r\nconst win = typeof window == 'object'\r\nlet THREE = win && window.THREE\r\nconst GPGPU = !(0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.mobileCheck)()\r\n\r\nlet WIDTH = 32\r\nlet BIRDS = WIDTH * WIDTH\r\nconst BOUNDS = 800\r\nconst BOUNDS_HALF = BOUNDS / 2\r\n\r\n\r\nconst getNewBirdGeometry = (options) => {\r\n  const scope = new THREE.BufferGeometry()\r\n\r\n  if (options.quantity) {\r\n    WIDTH = Math.pow(2, options.quantity)\r\n    BIRDS = WIDTH * WIDTH\r\n  }\r\n  const triangles = BIRDS * 3\r\n  const points = triangles * 3\r\n\r\n  const vertices = new THREE.BufferAttribute(new Float32Array(points * 3), 3)\r\n  const birdColors = new THREE.BufferAttribute(new Float32Array(points * 3), 3)\r\n  const references = new THREE.BufferAttribute(new Float32Array(points * 2), 2)\r\n  const birdVertex = new THREE.BufferAttribute(new Float32Array(points), 1)\r\n\r\n  if (!scope.setAttribute) scope.setAttribute = scope.addAttribute // handle three.js migration r109 â†’ r110\r\n  scope.setAttribute('position', vertices)\r\n  scope.setAttribute('birdColor', birdColors)\r\n  scope.setAttribute('reference', references)\r\n  scope.setAttribute('birdVertex', birdVertex)\r\n  // scope.addAttribute( 'normal', new Float32Array( points * 3 ), 3 )\r\n\r\n  let v = 0\r\n  const verts_push = function() {\r\n    for (let i=0; i<arguments.length; i++) {\r\n      vertices.array[v++] = arguments[i]\r\n    }\r\n  }\r\n\r\n  const wingSpan = options.wingSpan || 20\r\n  const s = options.birdSize || 1\r\n\r\n  for (let f=0; f<BIRDS; f++) {\r\n    verts_push(0, -0, -20*s, 0, 4*s, -20*s, 0, 0, 30*s) // Body\r\n    verts_push(0, 0, -15*s, -wingSpan*s, 0, 0, 0, 0, 15*s) // Left Wing\r\n    verts_push(0, 0, 15*s, wingSpan*s, 0, 0, 0, 0, -15*s) // Right Wing\r\n  }\r\n\r\n  const colorCache = {}\r\n\r\n  for (v=0; v<triangles*3; v++) {\r\n    const i = ~~(v / 3)\r\n    const x = (i % WIDTH) / WIDTH\r\n    const y = ~~(i / WIDTH) / WIDTH\r\n    const order = ~~(v / 9) / BIRDS\r\n    const key = order.toString()\r\n    const gradient = options.colorMode.indexOf('Gradient') != -1\r\n    let c\r\n    if (!gradient && colorCache[key]) {\r\n      c = colorCache[key]\r\n    } else {\r\n      c = options.effect.getNewCol(order)\r\n    }\r\n    if (!gradient && !colorCache[key]) {\r\n      colorCache[key] = c\r\n    }\r\n\r\n    birdColors.array[(v * 3) + 0] = c.r\r\n    birdColors.array[(v * 3) + 1] = c.g\r\n    birdColors.array[(v * 3) + 2] = c.b\r\n    references.array[v * 2] = x\r\n    references.array[(v * 2) + 1] = y\r\n    birdVertex.array[v] = v % 9\r\n  }\r\n  return scope.scale(0.2, 0.2, 0.2)\r\n}\r\n\r\nconst getNewBirdGeometryBasic = (options={}) => {\r\n  const scope = new THREE.BufferGeometry()\r\n  const points = []\r\n  function v( x, y, z ) {\r\n    const s = 1.5 * (options.birdSize || 1)\r\n    points.push( new THREE.Vector3( x*s, y*s, z*s ) )\r\n  }\r\n  v(   5,   0,   0 )\r\n  v( - 5, - 1,   1 )\r\n  v( - 5,   0,   0 )\r\n  v( - 5, - 2, - 1 )\r\n  v(   0,   2, - 6 )\r\n  v(   0,   2,   6 )\r\n  v(   2,   0,   0 )\r\n  v( - 3,   0,   0 )\r\n  scope.setFromPoints(points)\r\n\r\n  const indices = []\r\n  indices.push( 0, 2, 1 )\r\n  // f3( 0, 3, 2 )\r\n  indices.push( 4, 7, 6 )\r\n  indices.push( 5, 6, 7 )\r\n  scope.setIndex(indices)\r\n\r\n  // this.computeCentroids()\r\n  return scope\r\n}\r\n\r\n// Based on http://www.openprocessing.org/visuals/?visualID=6910\r\nclass Boid {\r\n  constructor (options) {\r\n    var vector = new THREE.Vector3(),\r\n    _acceleration,\r\n    _width = 500,\r\n    _height = 500,\r\n    _depth = 200, _goal,\r\n    _neighborhoodRadius = 100,\r\n    _maxSpeed = 2.5,\r\n    _maxSteerForce = 0.1,\r\n    _avoidWalls = true;\r\n\r\n    var _options = options\r\n\r\n    this.position = new THREE.Vector3()\r\n    this.velocity = new THREE.Vector3()\r\n    _acceleration = new THREE.Vector3()\r\n\r\n    this.setGoal = function ( target ) {\r\n      _goal = target;\r\n    }\r\n\r\n    // this.setAvoidWalls = function ( value ) {\r\n    //   _avoidWalls = value;\r\n    // }\r\n\r\n    this.setWorldSize = function ( width, height, depth ) {\r\n      _width = width;\r\n      _height = height;vector\r\n      _depth = depth;\r\n    }\r\n\r\n    this.run = function ( boids ) {\r\n      if ( _avoidWalls ) {\r\n        vector.set( - _width, this.position.y, this.position.z )\r\n        vector = this.avoid( vector )\r\n        vector.multiplyScalar( 5 )\r\n        _acceleration.add( vector )\r\n\r\n        vector.set( _width, this.position.y, this.position.z )\r\n        vector = this.avoid( vector )\r\n        vector.multiplyScalar( 5 )\r\n        _acceleration.add( vector )\r\n\r\n        vector.set( this.position.x, - _height, this.position.z )\r\n        vector = this.avoid( vector )\r\n        vector.multiplyScalar( 5 )\r\n        _acceleration.add( vector )\r\n\r\n        vector.set( this.position.x, _height, this.position.z )\r\n        vector = this.avoid( vector )\r\n        vector.multiplyScalar( 5 )\r\n        _acceleration.add( vector )\r\n\r\n        vector.set( this.position.x, this.position.y, - _depth )\r\n        vector = this.avoid( vector )\r\n        vector.multiplyScalar( 5 )\r\n        _acceleration.add( vector )\r\n\r\n        vector.set( this.position.x, this.position.y, _depth )\r\n        vector = this.avoid( vector )\r\n        vector.multiplyScalar( 5 )\r\n        _acceleration.add( vector )\r\n      }/* else {\r\n        this.checkBounds();\r\n      }*/\r\n\r\n      if ( Math.random() > 0.5 ) {\r\n        this.flock( boids )\r\n      }\r\n      this.move()\r\n    }\r\n\r\n    this.flock = function ( boids ) {\r\n      if ( _goal ) {\r\n        _acceleration.add( this.reach( _goal, 0.005 ) )\r\n      }\r\n      _acceleration.add( this.alignment( boids ) )\r\n      _acceleration.add( this.cohesion( boids ) )\r\n      _acceleration.add( this.separation( boids ) )\r\n    }\r\n\r\n    this.move = function () {\r\n      this.velocity.add( _acceleration )\r\n      var l = this.velocity.length()\r\n      if ( l > _maxSpeed ) {\r\n        this.velocity.divideScalar( l / _maxSpeed )\r\n      }\r\n      this.position.add( this.velocity )\r\n      _acceleration.set( 0, 0, 0 )\r\n    }\r\n\r\n    this.checkBounds = function () {\r\n      if ( this.position.x >   _width ) this.position.x = - _width;\r\n      if ( this.position.x < - _width ) this.position.x =   _width;\r\n      if ( this.position.y >   _height ) this.position.y = - _height;\r\n      if ( this.position.y < - _height ) this.position.y =  _height;\r\n      if ( this.position.z >  _depth ) this.position.z = - _depth;\r\n      if ( this.position.z < - _depth ) this.position.z =  _depth;\r\n    }\r\n\r\n    this.avoid = function ( target ) {\r\n      var steer = new THREE.Vector3()\r\n      steer.copy( this.position )\r\n      steer.sub( target )\r\n      steer.multiplyScalar( 1 / this.position.distanceToSquared( target ) )\r\n      return steer\r\n    }\r\n\r\n    this.repulse = function ( target ) {\r\n      var distance = this.position.distanceTo( target )\r\n      if ( distance < 150 ) {\r\n        var steer = new THREE.Vector3()\r\n        steer.subVectors( this.position, target )\r\n        steer.multiplyScalar( 0.5 / distance )\r\n        _acceleration.add( steer )\r\n      }\r\n    }\r\n\r\n    this.reach = function ( target, amount ) {\r\n      var steer = new THREE.Vector3()\r\n      steer.subVectors( target, this.position )\r\n      steer.multiplyScalar( amount )\r\n      return steer\r\n    }\r\n\r\n    this.alignment = function ( boids ) {\r\n      var boid, velSum = new THREE.Vector3(), count = 0, distance\r\n      const radius = _neighborhoodRadius * _options.alignment/20\r\n      for ( var i = 0, il = boids.length; i < il; i++ ) {\r\n        if ( Math.random() > 0.6 ) continue\r\n        boid = boids[ i ]\r\n        distance = boid.position.distanceTo( this.position )\r\n        if ( distance > 0 && distance <= radius ) {\r\n          velSum.add( boid.velocity )\r\n          count++\r\n        }\r\n      }\r\n      if ( count > 0 ) {\r\n        velSum.divideScalar( count )\r\n        var l = velSum.length()\r\n        if ( l > _maxSteerForce ) {\r\n          velSum.divideScalar( l / _maxSteerForce )\r\n        }\r\n      }\r\n      return velSum\r\n    }\r\n\r\n    this.cohesion = function ( boids ) {\r\n      var boid, distance,\r\n      posSum = new THREE.Vector3(),\r\n      steer = new THREE.Vector3(),\r\n      count = 0\r\n      const radius = _neighborhoodRadius * _options.cohesion/20\r\n\r\n      for ( var i = 0, il = boids.length; i < il; i ++ ) {\r\n        if ( Math.random() > 0.6 ) continue\r\n        boid = boids[ i ]\r\n        distance = boid.position.distanceTo( this.position )\r\n\r\n        if ( distance > 0 && distance <= radius ) {\r\n          posSum.add( boid.position )\r\n          count++\r\n        }\r\n      }\r\n      if ( count > 0 ) {\r\n        posSum.divideScalar( count )\r\n      }\r\n      steer.subVectors( posSum, this.position )\r\n      var l = steer.length()\r\n      if ( l > _maxSteerForce ) {\r\n        steer.divideScalar( l / _maxSteerForce )\r\n      }\r\n      return steer\r\n    }\r\n\r\n    this.separation = function ( boids ) {\r\n      var boid, distance,\r\n        posSum = new THREE.Vector3(),\r\n        repulse = new THREE.Vector3()\r\n      const radius = _neighborhoodRadius * _options.separation/20\r\n\r\n      for ( var i = 0, il = boids.length; i < il; i ++ ) {\r\n        if ( Math.random() > 0.6 ) continue\r\n        boid = boids[ i ]\r\n        distance = boid.position.distanceTo( this.position )\r\n        if ( distance > 0 && distance <= radius ) {\r\n          repulse.subVectors( this.position, boid.position )\r\n          repulse.normalize()\r\n          repulse.divideScalar( distance )\r\n          posSum.add( repulse )\r\n        }\r\n      }\r\n      return posSum\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\nconst fragmentShaderPosition = `\\\r\nuniform float time;\r\nuniform float delta;\r\n\r\nvoid main() {\r\n\r\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n  vec4 tmpPos = texture2D( texturePosition, uv );\r\n  vec3 position = tmpPos.xyz;\r\n  vec3 velocity = texture2D( textureVelocity, uv ).xyz;\r\n\r\n  float phase = tmpPos.w;\r\n\r\n  phase = mod( ( phase + delta +\r\n    length( velocity.xz ) * delta * 3. +\r\n    max( velocity.y, 0.0 ) * delta * 6. ), 62.83 );\r\n\r\n  gl_FragColor = vec4( position + velocity * delta * 15. , phase );\r\n\r\n}`\r\n\r\nconst fragmentShaderVelocity = `\\\r\nuniform float time;\r\nuniform float testing;\r\nuniform float delta; // about 0.016\r\nuniform float separationDistance; // 20\r\nuniform float alignmentDistance; // 40\r\nuniform float cohesionDistance;\r\nuniform float speedLimit;\r\nuniform float freedomFactor;\r\nuniform vec3 predator;\r\n\r\nconst float width = resolution.x;\r\nconst float height = resolution.y;\r\n\r\nconst float PI = 3.141592653589793;\r\nconst float PI_2 = PI * 2.0;\r\n// const float VISION = PI * 0.55;\r\n\r\nfloat zoneRadius = 40.0;\r\nfloat zoneRadiusSquared = 1600.0;\r\n\r\nfloat separationThresh = 0.45;\r\nfloat alignmentThresh = 0.65;\r\n\r\nconst float UPPER_BOUNDS = BOUNDS;\r\nconst float LOWER_BOUNDS = -UPPER_BOUNDS;\r\n\r\nfloat rand(vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvoid main() {\r\n\r\n  zoneRadius = separationDistance + alignmentDistance + cohesionDistance;\r\n  separationThresh = separationDistance / zoneRadius;\r\n  alignmentThresh = ( separationDistance + alignmentDistance ) / zoneRadius;\r\n  zoneRadiusSquared = zoneRadius * zoneRadius;\r\n\r\n\r\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n  vec3 birdPosition, birdVelocity;\r\n\r\n  vec3 selfPosition = texture2D( texturePosition, uv ).xyz;\r\n  vec3 selfVelocity = texture2D( textureVelocity, uv ).xyz;\r\n\r\n  float dist;\r\n  vec3 dir; // direction\r\n  float distSquared;\r\n\r\n  float separationSquared = separationDistance * separationDistance;\r\n  float cohesionSquared = cohesionDistance * cohesionDistance;\r\n\r\n  float f;\r\n  float percent;\r\n\r\n  vec3 velocity = selfVelocity;\r\n\r\n  float limit = speedLimit;\r\n\r\n  dir = predator * UPPER_BOUNDS - selfPosition;\r\n  dir.z = 0.;\r\n  // dir.z *= 0.6;\r\n  dist = length( dir );\r\n  distSquared = dist * dist;\r\n\r\n  float preyRadius = 150.0;\r\n  float preyRadiusSq = preyRadius * preyRadius;\r\n\r\n  // move birds away from predator\r\n  if (dist < preyRadius) {\r\n\r\n    f = ( distSquared / preyRadiusSq - 1.0 ) * delta * 100.;\r\n    velocity += normalize( dir ) * f;\r\n    limit += 5.0;\r\n  }\r\n\r\n  // if (testing == 0.0) {}\r\n  // if ( rand( uv + time ) < freedomFactor ) {}\r\n\r\n  // Attract flocks to the center\r\n  vec3 central = vec3( 0., 0., 0. );\r\n  dir = selfPosition - central;\r\n  dist = length( dir );\r\n\r\n  dir.y *= 2.5;\r\n  velocity -= normalize( dir ) * delta * 5.;\r\n\r\n  for (float y=0.0;y<height;y++) {\r\n    for (float x=0.0;x<width;x++) {\r\n\r\n      vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;\r\n      birdPosition = texture2D( texturePosition, ref ).xyz;\r\n\r\n      dir = birdPosition - selfPosition;\r\n      dist = length(dir);\r\n\r\n      if (dist < 0.0001) continue;\r\n\r\n      distSquared = dist * dist;\r\n\r\n      if (distSquared > zoneRadiusSquared ) continue;\r\n\r\n      percent = distSquared / zoneRadiusSquared;\r\n\r\n      if ( percent < separationThresh ) { // low\r\n\r\n        // Separation - Move apart for comfort\r\n        f = (separationThresh / percent - 1.0) * delta;\r\n        velocity -= normalize(dir) * f;\r\n\r\n      } else if ( percent < alignmentThresh ) { // high\r\n\r\n        // Alignment - fly the same direction\r\n        float threshDelta = alignmentThresh - separationThresh;\r\n        float adjustedPercent = ( percent - separationThresh ) / threshDelta;\r\n\r\n        birdVelocity = texture2D( textureVelocity, ref ).xyz;\r\n\r\n        f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;\r\n        velocity += normalize(birdVelocity) * f;\r\n\r\n      } else {\r\n\r\n        // Attraction / Cohesion - move closer\r\n        float threshDelta = 1.0 - alignmentThresh;\r\n        float adjustedPercent = ( percent - alignmentThresh ) / threshDelta;\r\n\r\n        f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;\r\n\r\n        velocity += normalize(dir) * f;\r\n\r\n      }\r\n    }\r\n  }\r\n\r\n  // this make tends to fly around than down or up\r\n  // if (velocity.y > 0.) velocity.y *= (1. - 0.2 * delta);\r\n\r\n  // Speed Limits\r\n  if ( length( velocity ) > limit ) {\r\n    velocity = normalize( velocity ) * limit;\r\n  }\r\n\r\n  gl_FragColor = vec4( velocity, 1.0 );\r\n\r\n}`\r\n\r\nconst birdVS = `\\\r\nattribute vec2 reference;\r\nattribute float birdVertex;\r\n\r\nattribute vec3 birdColor;\r\n\r\nuniform sampler2D texturePosition;\r\nuniform sampler2D textureVelocity;\r\n\r\nvarying vec4 vColor;\r\nvarying float z;\r\n\r\nuniform float time;\r\nuniform float birdSize;\r\n\r\nvoid main() {\r\n\r\n  vec4 tmpPos = texture2D( texturePosition, reference );\r\n  vec3 pos = tmpPos.xyz;\r\n  vec3 velocity = normalize(texture2D( textureVelocity, reference ).xyz);\r\n\r\n  vec3 newPosition = position;\r\n\r\n  if ( birdVertex == 4.0 || birdVertex == 7.0 ) {\r\n    // flap wings\r\n    newPosition.y = sin( tmpPos.w ) * 5. * birdSize;\r\n  }\r\n\r\n  newPosition = mat3( modelMatrix ) * newPosition;\r\n\r\n  velocity.z *= -1.;\r\n  float xz = length( velocity.xz );\r\n  float xyz = 1.;\r\n  float x = sqrt( 1. - velocity.y * velocity.y );\r\n\r\n  float cosry = velocity.x / xz;\r\n  float sinry = velocity.z / xz;\r\n\r\n  float cosrz = x / xyz;\r\n  float sinrz = velocity.y / xyz;\r\n\r\n  mat3 maty =  mat3(\r\n    cosry, 0, -sinry,\r\n    0    , 1, 0     ,\r\n    sinry, 0, cosry\r\n  );\r\n\r\n  mat3 matz =  mat3(\r\n    cosrz , sinrz, 0,\r\n    -sinrz, cosrz, 0,\r\n    0     , 0    , 1\r\n  );\r\n  newPosition =  maty * matz * newPosition;\r\n  newPosition += pos;\r\n  z = newPosition.z;\r\n\r\n  vColor = vec4( birdColor, 1.0 );\r\n  gl_Position = projectionMatrix *  viewMatrix  * vec4( newPosition, 1.0 );\r\n}`\r\n\r\nconst birdFS = `\\\r\nvarying vec4 vColor;\r\nvarying float z;\r\nuniform vec3 color;\r\nvoid main() {\r\n  // Fake colors for now\r\n  float rr = 0.2 + ( 1000. - z ) / 1000. * vColor.x;\r\n  float gg = 0.2 + ( 1000. - z ) / 1000. * vColor.y;\r\n  float bb = 0.2 + ( 1000. - z ) / 1000. * vColor.z;\r\n  gl_FragColor = vec4( rr, gg, bb, 1. );\r\n}`\r\n\r\nconst fillPositionTexture = function(texture) {\r\n  const theArray = texture.image.data\r\n  let k = 0\r\n  const kl = theArray.length\r\n  return (() => {\r\n    const result = []\r\n    while (k < kl) {\r\n      const x = (Math.random() * BOUNDS) - BOUNDS_HALF\r\n      const y = (Math.random() * BOUNDS) - BOUNDS_HALF\r\n      const z = (Math.random() * BOUNDS) - BOUNDS_HALF\r\n      theArray[k + 0] = x\r\n      theArray[k + 1] = y\r\n      theArray[k + 2] = z\r\n      theArray[k + 3] = 1\r\n      result.push(k += 4)\r\n    }\r\n    return result\r\n  })()\r\n}\r\n\r\nconst fillVelocityTexture = function(texture) {\r\n  const theArray = texture.image.data\r\n  let k = 0\r\n  const kl = theArray.length\r\n  return (() => {\r\n    const result = []\r\n    while (k < kl) {\r\n      const x = Math.random() - 0.5\r\n      const y = Math.random() - 0.5\r\n      const z = Math.random() - 0.5\r\n      theArray[k + 0] = x * 10\r\n      theArray[k + 1] = y * 10\r\n      theArray[k + 2] = z * 10\r\n      theArray[k + 3] = 1\r\n      result.push(k += 4)\r\n    }\r\n    return result\r\n  })()\r\n}\r\n\r\nclass Birds extends _base_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  static initClass() {\r\n    this.prototype.defaultOptions = {\r\n      // Beige: 0xf8e8d0, 0xf50000, 0xcfcf1d\r\n      backgroundColor: 0x07192F, // 0x202428\r\n      color1: 0xff0000, // 0xf50000 # 0xfa9898\r\n      color2: 0x00d1ff, // 0xcfcf1d # 0x8c4646\r\n      colorMode: 'varianceGradient',\r\n      birdSize: 1,\r\n      wingSpan: 30,\r\n      speedLimit: 5,\r\n      separation: 20,\r\n      alignment: 20,\r\n      cohesion: 20,\r\n      quantity: 5, // range from 2 to 5\r\n    }\r\n  }\r\n\r\n  constructor(userOptions) {\r\n    THREE = userOptions.THREE || THREE\r\n    super(userOptions)\r\n  }\r\n\r\n  initComputeRenderer() {\r\n    this.gpuCompute = new _vendor_GPUComputationRenderer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](WIDTH, WIDTH, this.renderer, THREE)\r\n    const dtPosition = this.gpuCompute.createTexture()\r\n    const dtVelocity = this.gpuCompute.createTexture()\r\n    fillPositionTexture(dtPosition)\r\n    fillVelocityTexture(dtVelocity)\r\n    this.velocityVariable = this.gpuCompute.addVariable('textureVelocity', fragmentShaderVelocity, dtVelocity)\r\n    this.positionVariable = this.gpuCompute.addVariable('texturePosition', fragmentShaderPosition, dtPosition)\r\n    this.gpuCompute.setVariableDependencies(this.velocityVariable, [\r\n      this.positionVariable,\r\n      this.velocityVariable\r\n    ])\r\n    this.gpuCompute.setVariableDependencies(this.positionVariable, [\r\n      this.positionVariable,\r\n      this.velocityVariable\r\n    ])\r\n    this.positionUniforms = this.positionVariable.material.uniforms\r\n    this.velocityUniforms = this.velocityVariable.material.uniforms\r\n    this.positionUniforms.time = {value: 0.0}\r\n    this.positionUniforms.delta = {value: 0.0}\r\n    this.velocityUniforms.time = {value: 1.0}\r\n    this.velocityUniforms.delta = {value: 0.0}\r\n    this.velocityUniforms.testing = {value: 1.0}\r\n    this.velocityUniforms.separationDistance = {value: 1.0}\r\n    this.velocityUniforms.alignmentDistance = {value: 1.0}\r\n    this.velocityUniforms.cohesionDistance = {value: 1.0}\r\n    this.velocityUniforms.speedLimit = {value: 1.0}\r\n    this.velocityUniforms.freedomFactor = {value: 1.0}\r\n    this.velocityUniforms.predator = {value: new THREE.Vector3}\r\n    this.velocityVariable.material.defines.BOUNDS = BOUNDS.toFixed(2)\r\n    this.velocityVariable.wrapS = THREE.RepeatWrapping\r\n    this.velocityVariable.wrapT = THREE.RepeatWrapping\r\n    this.positionVariable.wrapS = THREE.RepeatWrapping\r\n    this.positionVariable.wrapT = THREE.RepeatWrapping\r\n    const error = this.gpuCompute.init()\r\n    if (error !== null) {\r\n      console.error(error)\r\n    }\r\n  }\r\n\r\n  initGpgpuBirds() {\r\n    const optionsWithEffect = Object.assign({}, this.options, {effect:this})\r\n    const geometry = getNewBirdGeometry(optionsWithEffect)\r\n    // For Vertex and Fragment\r\n    this.birdUniforms = {\r\n      color: { value: new THREE.Color(0xff2200) },\r\n      texturePosition: { value: null },\r\n      textureVelocity: { value: null },\r\n      time: { value: 1.0 },\r\n      delta: { value: 0.0 },\r\n      birdSize: {value: this.options.birdSize}\r\n    }\r\n    // ShaderMaterial\r\n    const material = new THREE.ShaderMaterial({\r\n      uniforms: this.birdUniforms,\r\n      vertexShader: birdVS,\r\n      fragmentShader: birdFS,\r\n      side: THREE.DoubleSide\r\n    });\r\n    const birdMesh = new THREE.Mesh(geometry, material)\r\n    birdMesh.rotation.y = Math.PI / 2\r\n    birdMesh.matrixAutoUpdate = false\r\n    birdMesh.updateMatrix()\r\n    return this.scene.add(birdMesh)\r\n  }\r\n\r\n  getNewCol(order) {\r\n    const options = this.options\r\n    const color1 = options.color1 != null ? options.color1 : 0x440000\r\n    const color2 = options.color2 != null ? options.color2 : 0x660000\r\n    const c1 = new THREE.Color(color1)\r\n    const c2 = new THREE.Color(color2)\r\n    const gradient = options.colorMode.indexOf('Gradient') != -1\r\n    let c, dist\r\n    if (gradient) {\r\n      // each vertex has a different color\r\n      dist = Math.random()\r\n    } else {\r\n      // each vertex has the same color\r\n      dist = order\r\n    }\r\n\r\n    if (options.colorMode.indexOf('variance') == 0) {\r\n      const r2 = (c1.r + Math.random() * c2.r).clamp(0,1)\r\n      const g2 = (c1.g + Math.random() * c2.g).clamp(0,1)\r\n      const b2 = (c1.b + Math.random() * c2.b).clamp(0,1)\r\n      c = new THREE.Color(r2, g2, b2)\r\n    } else if (options.colorMode.indexOf('mix') == 0) {\r\n      // Naive color arithmetic\r\n      c = new THREE.Color(color1 + dist * color2)\r\n    } else {\r\n      // Linear interpolation\r\n      c = c1.lerp(c2, dist)\r\n    }\r\n    return c\r\n  }\r\n\r\n  onInit() {\r\n    this.camera = new THREE.PerspectiveCamera( 75, this.width / this.height, 1, 3000 )\r\n    this.camera.position.z = 350\r\n    this.fog = new THREE.Fog( 0xffffff, 100, 1000 )\r\n    this.mouseX = (this.mouseY = 0)\r\n\r\n    const birds = this.birds = []\r\n\t\tconst boids = this.boids = []\r\n    const options = this.options\r\n    let boid, bird\r\n\r\n    if (GPGPU) {\r\n      try {\r\n        this.initComputeRenderer()\r\n        this.valuesChanger = this.valuesChanger.bind(this)\r\n        this.valuesChanger()\r\n        this.initGpgpuBirds()\r\n      } catch (err) {\r\n        console.error('[vanta.js] birds init error: ', err)\r\n      }\r\n    } else {\r\n      const numBirds = 6 * Math.pow(2, options.quantity)\r\n      for (var i = 0; i < numBirds; i++) {\r\n        boid = boids[i] = new Boid(options)\r\n        boid.position.x = Math.random() * 400 - 200\r\n        boid.position.y = Math.random() * 400 - 200\r\n        boid.position.z = Math.random() * 400 - 200\r\n        boid.velocity.x = Math.random() * 2 - 1\r\n        boid.velocity.y = Math.random() * 2 - 1\r\n        boid.velocity.z = Math.random() * 2 - 1\r\n        boid.setWorldSize( 500, 500, 300 )\r\n\r\n        const gradient = options.colorMode.indexOf('Gradient') != -1\r\n\r\n        const newBirdGeo = getNewBirdGeometryBasic(options)\r\n        const numV = newBirdGeo.attributes.position.length\r\n        const birdColors = new THREE.BufferAttribute(new Float32Array(numV), 3)\r\n        if (gradient) {\r\n          for (var j=0; j<newBirdGeo.index.array.length; j+=3) {\r\n            for (var k=0; k<=2; k++) {\r\n              const index = newBirdGeo.index.array[j+k]\r\n              const newColor = this.getNewCol()\r\n              birdColors.array[index*3] = newColor.r\r\n              birdColors.array[index*3+1] = newColor.g\r\n              birdColors.array[index*3+2] = newColor.b\r\n            }\r\n          }\r\n        } else {\r\n          const newColor = this.getNewCol(i/numBirds)\r\n          for (var j=0; j<birdColors.array.length; j+=3) {\r\n            birdColors.array[j] = newColor.r\r\n            birdColors.array[j+1] = newColor.g\r\n            birdColors.array[j+2] = newColor.b\r\n          }\r\n        }\r\n        newBirdGeo.setAttribute('color', birdColors)\r\n\r\n        bird = birds[i] = new THREE.Mesh(\r\n          newBirdGeo,\r\n          new THREE.MeshBasicMaterial( {\r\n            color: 0xffffff,\r\n            side: THREE.DoubleSide,\r\n            // colors: THREE.VertexColors,\r\n\t\t\t\t\t  vertexColors: THREE.VertexColors,\r\n          }))\r\n        bird.phase = Math.floor( Math.random() * 62.83 )\r\n        bird.position.x = boids[i].position.x\r\n        bird.position.y = boids[i].position.y\r\n        bird.position.z = boids[i].position.z\r\n        this.scene.add( bird )\r\n        // if (i == 0) {\r\n        //   window.bird = bird; window.boid = boid;\r\n        // }\r\n      }\r\n    }\r\n  }\r\n\r\n  valuesChanger() {\r\n    if (this.velocityUniforms) {\r\n      this.velocityUniforms.separationDistance.value = this.options.separation\r\n      this.velocityUniforms.alignmentDistance.value = this.options.alignment\r\n      this.velocityUniforms.speedLimit.value = this.options.speedLimit\r\n      this.velocityUniforms.cohesionDistance.value = this.options.cohesion\r\n    }\r\n  }\r\n\r\n  onUpdate() {\r\n    this.now = performance.now()\r\n    if (!this.last) { this.last = this.now }\r\n    let delta = (this.now - this.last) / 1000\r\n\r\n    if (delta > 1) { delta = 1 }\r\n    this.last = this.now\r\n\r\n    if (GPGPU) {\r\n      this.positionUniforms.time.value = this.now\r\n      this.positionUniforms.delta.value = delta\r\n      this.velocityUniforms.time.value = this.now\r\n      this.velocityUniforms.delta.value = delta\r\n      this.birdUniforms.time.value = this.now\r\n      this.birdUniforms.delta.value = delta\r\n      this.velocityUniforms.predator.value.set(\r\n        this.mouseX,\r\n        -this.mouseY,\r\n        0\r\n      )\r\n      this.mouseX = 10000\r\n      this.mouseY = 10000\r\n      this.gpuCompute.compute()\r\n      this.birdUniforms.texturePosition.value = this.gpuCompute.getCurrentRenderTarget( this.positionVariable ).texture\r\n      this.birdUniforms.textureVelocity.value = this.gpuCompute.getCurrentRenderTarget( this.velocityVariable ).texture\r\n    } else {\r\n      const birds = this.birds\r\n      const boids = this.boids\r\n      let boid, bird, color\r\n      for ( var i = 0, il = birds.length; i < il; i++ ) {\r\n        boid = boids[i]\r\n        boid.run( boids )\r\n        bird = birds[i]\r\n        // color = bird.material.color\r\n        // color.r = color.g = color.b = ( 500 - bird.position.z ) / 1000\r\n        bird.rotation.y = Math.atan2( - boid.velocity.z, boid.velocity.x )\r\n        bird.rotation.z = Math.asin( boid.velocity.y / boid.velocity.length() )\r\n        // Flapping\r\n        bird.phase = (bird.phase + (Math.max(0, bird.rotation.z)+0.1)) % 62.83\r\n\r\n        const tip1 = 5*3 + 1\r\n        const tip2 = 4*3 + 1\r\n        bird.geometry.attributes.position.array[tip1] = bird.geometry.attributes.position.array[tip2] =\r\n          Math.sin( bird.phase ) * 5 * this.options.birdSize\r\n        bird.geometry.attributes.position.needsUpdate = true\r\n        bird.geometry.computeVertexNormals()\r\n\r\n        bird.position.x = boids[i].position.x\r\n        bird.position.y = boids[i].position.y\r\n        bird.position.z = boids[i].position.z\r\n      }\r\n    }\r\n  }\r\n  onMouseMove(x,y) {\r\n    // Center on 0,0\r\n    this.mouseX = x - 0.5\r\n    this.mouseY = y - 0.5\r\n    if (!GPGPU) {\r\n      const boids = this.boids\r\n      let boid\r\n      var vector = new THREE.Vector3( this.mouseX * this.width, -this.mouseY * this.height, 0 );\r\n      for ( var i = 0, il = boids.length; i < il; i++ ) {\r\n        boid = boids[i]\r\n        vector.z = boid.position.z\r\n        boid.repulse( vector )\r\n\t\t\t}\r\n    }\r\n  }\r\n  onDestroy() {}\r\n  onResize() {}\r\n}\r\nBirds.initClass()\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_base_js__WEBPACK_IMPORTED_MODULE_0__.VANTA.register('BIRDS', Birds));\n\n//# sourceURL=webpack://Synthesizer/./node_modules/vanta/src/vanta.birds.js?");

/***/ }),

/***/ "./node_modules/vanta/vendor/GPUComputationRenderer.js":
/*!*************************************************************!*\
  !*** ./node_modules/vanta/vendor/GPUComputationRenderer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst win = typeof window == 'object'\r\nlet THREE = win && window.THREE\r\nlet {\r\n\tCamera,\r\n\tClampToEdgeWrapping,\r\n\tDataTexture,\r\n\tFloatType,\r\n\tMesh,\r\n\tNearestFilter,\r\n\tPlaneBufferGeometry,\r\n\tRGBAFormat,\r\n\tScene,\r\n\tShaderMaterial,\r\n\tWebGLRenderTarget\r\n} = (THREE || {})\r\n\r\n/**\r\n * GPUComputationRenderer, based on SimulationRenderer by zz85\r\n *\r\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\r\n * for each compute element (texel)\r\n *\r\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\r\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\r\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\r\n *\r\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\r\n * as inputs to render the textures of the next frame.\r\n *\r\n * The render targets of the variables can be used as input textures for your visualization shaders.\r\n *\r\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\r\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\r\n *\r\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\r\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\r\n *\r\n * -------------\r\n *\r\n * Basic use:\r\n *\r\n * // Initialization...\r\n *\r\n * // Create computation renderer\r\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\r\n *\r\n * // Create initial state float textures\r\n * var pos0 = gpuCompute.createTexture();\r\n * var vel0 = gpuCompute.createTexture();\r\n * // and fill in here the texture data...\r\n *\r\n * // Add texture variables\r\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\r\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\r\n *\r\n * // Add variable dependencies\r\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\r\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\r\n *\r\n * // Add custom uniforms\r\n * velVar.material.uniforms.time = { value: 0.0 };\r\n *\r\n * // Check for completeness\r\n * var error = gpuCompute.init();\r\n * if ( error !== null ) {\r\n *\t\tconsole.error( error );\r\n  * }\r\n *\r\n *\r\n * // In each frame...\r\n *\r\n * // Compute!\r\n * gpuCompute.compute();\r\n *\r\n * // Update texture uniforms in your visualization materials with the gpu renderer output\r\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\r\n *\r\n * // Do your rendering\r\n * renderer.render( myScene, myCamera );\r\n *\r\n * -------------\r\n *\r\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\r\n * Note that the shaders can have multiple input textures.\r\n *\r\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\r\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\r\n *\r\n * var inputTexture = gpuCompute.createTexture();\r\n *\r\n * // Fill in here inputTexture...\r\n *\r\n * myFilter1.uniforms.theTexture.value = inputTexture;\r\n *\r\n * var myRenderTarget = gpuCompute.createRenderTarget();\r\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\r\n *\r\n * var outputRenderTarget = gpuCompute.createRenderTarget();\r\n *\r\n * // Now use the output texture where you want:\r\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\r\n *\r\n * // And compute each frame, before rendering to screen:\r\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\r\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\r\n *\r\n *\r\n *\r\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\r\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\r\n * @param {WebGLRenderer} renderer The renderer\r\n  */\r\n\r\nvar GPUComputationRenderer = function ( sizeX, sizeY, renderer, userTHREE) {\r\n\tif (userTHREE) {\r\n\t\t({ Camera,\r\n\t\t\tClampToEdgeWrapping,\r\n\t\t\tDataTexture,\r\n\t\t\tFloatType,\r\n\t\t\tMesh,\r\n\t\t\tNearestFilter,\r\n\t\t\tPlaneBufferGeometry,\r\n\t\t\tRGBAFormat,\r\n\t\t\tScene,\r\n\t\t\tShaderMaterial,\r\n\t\t\tWebGLRenderTarget} = userTHREE)\r\n\t}\r\n\r\n\r\n\tthis.variables = [];\r\n\r\n\tthis.currentTextureIndex = 0;\r\n\r\n\tvar dataType = FloatType;\r\n\r\n\tvar scene = new Scene();\r\n\r\n\tvar camera = new Camera();\r\n\tcamera.position.z = 1;\r\n\r\n\tvar passThruUniforms = {\r\n\t\tpassThruTexture: { value: null }\r\n\t};\r\n\r\n\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\r\n\r\n\tvar mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), passThruShader );\r\n\tscene.add( mesh );\r\n\r\n\r\n\tthis.setDataType = function ( type ) {\r\n\r\n\t\tdataType = type;\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\r\n\r\n\t\tvar material = this.createShaderMaterial( computeFragmentShader );\r\n\r\n\t\tvar variable = {\r\n\t\t\tname: variableName,\r\n\t\t\tinitialValueTexture: initialValueTexture,\r\n\t\t\tmaterial: material,\r\n\t\t\tdependencies: null,\r\n\t\t\trenderTargets: [],\r\n\t\t\twrapS: null,\r\n\t\t\twrapT: null,\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter\r\n\t\t};\r\n\r\n\t\tthis.variables.push( variable );\r\n\r\n\t\treturn variable;\r\n\r\n\t};\r\n\r\n\tthis.setVariableDependencies = function ( variable, dependencies ) {\r\n\r\n\t\tvariable.dependencies = dependencies;\r\n\r\n\t};\r\n\r\n\tthis.init = function () {\r\n\r\n\t\tif ( ! renderer.capabilities.isWebGL2 &&\r\n\t\t\t ! renderer.extensions.get( \"OES_texture_float\" ) ) {\r\n\r\n\t\t\treturn \"No OES_texture_float support for float textures.\";\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\r\n\r\n\t\t\treturn \"No support for vertex shader textures.\";\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < this.variables.length; i ++ ) {\r\n\r\n\t\t\tvar variable = this.variables[ i ];\r\n\r\n\t\t\t// Creates rendertargets and initialize them with input texture\r\n\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\r\n\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\r\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\r\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\r\n\r\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\r\n\t\t\tvar material = variable.material;\r\n\t\t\tvar uniforms = material.uniforms;\r\n\r\n\t\t\tif ( variable.dependencies !== null ) {\r\n\r\n\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d ++ ) {\r\n\r\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\r\n\r\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\r\n\r\n\t\t\t\t\t\t// Checks if variable exists\r\n\t\t\t\t\t\tvar found = false;\r\n\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\r\n\r\n\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( ! found ) {\r\n\r\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\r\n\r\n\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTextureIndex = 0;\r\n\r\n\t\treturn null;\r\n\r\n\t};\r\n\r\n\tthis.compute = function () {\r\n\r\n\t\tvar currentTextureIndex = this.currentTextureIndex;\r\n\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\r\n\r\n\t\tfor ( var i = 0, il = this.variables.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar variable = this.variables[ i ];\r\n\r\n\t\t\t// Sets texture dependencies uniforms\r\n\t\t\tif ( variable.dependencies !== null ) {\r\n\r\n\t\t\t\tvar uniforms = variable.material.uniforms;\r\n\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\r\n\r\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\r\n\r\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Performs the computation for this variable\r\n\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTextureIndex = nextTextureIndex;\r\n\r\n\t};\r\n\r\n\tthis.getCurrentRenderTarget = function ( variable ) {\r\n\r\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\r\n\r\n\t};\r\n\r\n\tthis.getAlternateRenderTarget = function ( variable ) {\r\n\r\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\r\n\r\n\t};\r\n\r\n\tfunction addResolutionDefine( materialShader ) {\r\n\r\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\r\n\r\n\t}\r\n\r\n\tthis.addResolutionDefine = addResolutionDefine;\r\n\r\n\r\n\t// The following functions can be used to compute things manually\r\n\r\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\r\n\r\n\t\tuniforms = uniforms || {};\r\n\r\n\t\tvar material = new ShaderMaterial( {\r\n\t\t\tuniforms: uniforms,\r\n\t\t\tvertexShader: getPassThroughVertexShader(),\r\n\t\t\tfragmentShader: computeFragmentShader\r\n\t\t} );\r\n\r\n\t\taddResolutionDefine( material );\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n\tthis.createShaderMaterial = createShaderMaterial;\r\n\r\n\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\r\n\r\n\t\tsizeXTexture = sizeXTexture || sizeX;\r\n\t\tsizeYTexture = sizeYTexture || sizeY;\r\n\r\n\t\twrapS = wrapS || ClampToEdgeWrapping;\r\n\t\twrapT = wrapT || ClampToEdgeWrapping;\r\n\r\n\t\tminFilter = minFilter || NearestFilter;\r\n\t\tmagFilter = magFilter || NearestFilter;\r\n\r\n\t\tvar renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\r\n\t\t\twrapS: wrapS,\r\n\t\t\twrapT: wrapT,\r\n\t\t\tminFilter: minFilter,\r\n\t\t\tmagFilter: magFilter,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: dataType,\r\n\t\t\tstencilBuffer: false,\r\n\t\t\tdepthBuffer: false\r\n\t\t} );\r\n\r\n\t\treturn renderTarget;\r\n\r\n\t};\r\n\r\n\tthis.createTexture = function () {\r\n\r\n\t\tvar data = new Float32Array( sizeX * sizeY * 4 );\r\n\t\treturn new DataTexture( data, sizeX, sizeY, RGBAFormat, FloatType );\r\n\r\n\t};\r\n\r\n\tthis.renderTexture = function ( input, output ) {\r\n\r\n\t\t// Takes a texture, and render out in rendertarget\r\n\t\t// input = Texture\r\n\t\t// output = RenderTarget\r\n\r\n\t\tpassThruUniforms.passThruTexture.value = input;\r\n\r\n\t\tthis.doRenderTarget( passThruShader, output );\r\n\r\n\t\tpassThruUniforms.passThruTexture.value = null;\r\n\r\n\t};\r\n\r\n\tthis.doRenderTarget = function ( material, output ) {\r\n\r\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\tmesh.material = material;\r\n\t\trenderer.setRenderTarget( output );\r\n\t\trenderer.render( scene, camera );\r\n\t\tmesh.material = passThruShader;\r\n\r\n\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t};\r\n\r\n\t// Shaders\r\n\r\n\tfunction getPassThroughVertexShader() {\r\n\r\n\t\treturn\t\"void main()\t{\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"}\\n\";\r\n\r\n\t}\r\n\r\n\tfunction getPassThroughFragmentShader() {\r\n\r\n\t\treturn\t\"uniform sampler2D passThruTexture;\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"void main() {\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tgl_FragColor = texture2D( passThruTexture, uv );\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"}\\n\";\r\n\r\n\t}\r\n\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GPUComputationRenderer);\r\n\n\n//# sourceURL=webpack://Synthesizer/./node_modules/vanta/vendor/GPUComputationRenderer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./node_modules/vanta/src/vanta.birds.js");
/******/ 	
/******/ })()
;